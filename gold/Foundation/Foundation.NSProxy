@_exported import CoreFoundation

@_nonSendable(_assumed) class NSProxy : NSObjectProtocol {
  class func alloc() -> Self
  @available(*, unavailable, message: "not available in automatic reference counting mode")
  class func alloc(with zone: NSZone? = nil) -> Self
  @available(swift, obsoleted: 3, renamed: "alloc(with:)")
  @available(*, unavailable, message: "not available in automatic reference counting mode")
  class func allocWithZone(_ zone: NSZone? = nil) -> Self
  class func `class`() -> AnyClass
  class func forwardInvocation(_ invocation: NSInvocation)
  func forwardInvocation(_ invocation: NSInvocation)
  @available(*, unavailable, message: "NSInvocation and related APIs not available")
  class func methodSignature(for sel: Selector) -> NSMethodSignature?
  @available(*, unavailable, message: "NSInvocation and related APIs not available")
  func methodSignature(for sel: Selector) -> NSMethodSignature?
  @available(swift, obsoleted: 3, renamed: "methodSignature(for:)")
  @available(*, unavailable, message: "NSInvocation and related APIs not available")
  class func methodSignatureForSelector(_ sel: Selector) -> NSMethodSignature?
  @available(swift, obsoleted: 3, renamed: "methodSignature(for:)")
  @available(*, unavailable, message: "NSInvocation and related APIs not available")
  func methodSignatureForSelector(_ sel: Selector) -> NSMethodSignature?
  class func dealloc()
  func dealloc()
  class func finalize()
  func finalize()
  var description: String { get }
  var debugDescription: String { get }
  class func responds(to aSelector: Selector) -> Bool
  @available(swift, obsoleted: 3, renamed: "responds(to:)")
  class func respondsToSelector(_ aSelector: Selector) -> Bool
  @available(iOS, unavailable)
  class func allowsWeakReference() -> Bool
  @available(iOS, unavailable)
  func allowsWeakReference() -> Bool
  @available(iOS, unavailable)
  class func retainWeakReference() -> Bool
  @available(iOS, unavailable)
  func retainWeakReference() -> Bool
  class func description() -> String
  class func debugDescription() -> String
  var hash: Int { get }
  var superclass: AnyClass? { get }
  func isEqual(_ object: Any?) -> Bool
  class func isEqual(_ object: Any?) -> Bool
  @available(*, unavailable, message: "use 'type(of:)' instead")
  func `class`() -> AnyClass!
  func `self`() -> Self
  func perform(_ aSelector: Selector!) -> Unmanaged<AnyObject>!
  class func perform(_ aSelector: Selector!) -> Unmanaged<AnyObject>!
  func perform(_ aSelector: Selector!, with object: Any!) -> Unmanaged<AnyObject>!
  class func perform(_ aSelector: Selector!, with object: Any!) -> Unmanaged<AnyObject>!
  func perform(_ aSelector: Selector!, with object1: Any!, with object2: Any!) -> Unmanaged<AnyObject>!
  class func perform(_ aSelector: Selector!, with object1: Any!, with object2: Any!) -> Unmanaged<AnyObject>!
  func isProxy() -> Bool
  class func isProxy() -> Bool
  func isKind(of aClass: AnyClass) -> Bool
  class func isKind(of aClass: AnyClass) -> Bool
  func isMember(of aClass: AnyClass) -> Bool
  class func isMember(of aClass: AnyClass) -> Bool
  func conforms(to aProtocol: Protocol) -> Bool
  class func conforms(to aProtocol: Protocol) -> Bool
  func responds(to aSelector: Selector!) -> Bool
  @available(*, unavailable, message: "not available in automatic reference counting mode")
  func retain() -> Self!
  @available(*, unavailable, message: "not available in automatic reference counting mode")
  func release()
  @available(*, unavailable, message: "not available in automatic reference counting mode")
  class func release()
  @available(*, unavailable, message: "not available in automatic reference counting mode")
  func autorelease() -> Self!
  @available(*, unavailable, message: "not available in automatic reference counting mode")
  func retainCount() -> Int
  @available(*, unavailable, message: "not available in automatic reference counting mode")
  class func retainCount() -> Int
  @available(*, unavailable, message: "not available in automatic reference counting mode")
  func zone() -> NSZone!
  @available(*, unavailable, message: "not available in automatic reference counting mode")
  class func zone() -> NSZone!
}

@available(*, unavailable)
extension NSProxy : @unchecked Sendable {
}
