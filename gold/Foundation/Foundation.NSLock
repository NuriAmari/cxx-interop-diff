@_exported import CoreFoundation

protocol NSLocking {
  @_unavailableFromAsync(message: "Use async-safe scoped locking instead") func lock()
  @_unavailableFromAsync(message: "Use async-safe scoped locking instead") func unlock()
}

extension NSLocking {
  @_alwaysEmitIntoClient @_disfavoredOverload func withLock<R>(_ body: () throws -> R) rethrows -> R
}
@_nonSendable(_assumed) class NSLock : NSObject, NSLocking, @unchecked Sendable {
  @_unavailableFromAsync(message: "Use async-safe scoped locking instead") func `try`() -> Bool
  @available(swift, obsoleted: 3, renamed: "try()")
  @_unavailableFromAsync(message: "Use async-safe scoped locking instead") func tryLock() -> Bool
  @_unavailableFromAsync(message: "Use async-safe scoped locking instead") func lock(before limit: Date) -> Bool
  @available(swift, obsoleted: 3, renamed: "lock(before:)")
  @_unavailableFromAsync(message: "Use async-safe scoped locking instead") func lockBeforeDate(_ limit: Date) -> Bool
  @available(iOS 2.0, *)
  var name: String?
  init()
  @_unavailableFromAsync(message: "Use async-safe scoped locking instead") func lock()
  @_unavailableFromAsync(message: "Use async-safe scoped locking instead") func unlock()
}
@_nonSendable(_assumed) class NSConditionLock : NSObject, NSLocking, @unchecked Sendable {
  init(condition: Int)
  var condition: Int { get }
  @_unavailableFromAsync(message: "Use async-safe scoped locking instead") func lock(whenCondition condition: Int)
  @available(swift, obsoleted: 3, renamed: "lock(whenCondition:)")
  @_unavailableFromAsync(message: "Use async-safe scoped locking instead") func lockWhenCondition(_ condition: Int)
  @_unavailableFromAsync(message: "Use async-safe scoped locking instead") func `try`() -> Bool
  @available(swift, obsoleted: 3, renamed: "try()")
  @_unavailableFromAsync(message: "Use async-safe scoped locking instead") func tryLock() -> Bool
  @_unavailableFromAsync(message: "Use async-safe scoped locking instead") func tryLock(whenCondition condition: Int) -> Bool
  @available(swift, obsoleted: 3, renamed: "tryLock(whenCondition:)")
  @_unavailableFromAsync(message: "Use async-safe scoped locking instead") func tryLockWhenCondition(_ condition: Int) -> Bool
  @_unavailableFromAsync(message: "Use async-safe scoped locking instead") func unlock(withCondition condition: Int)
  @available(swift, obsoleted: 3, renamed: "unlock(withCondition:)")
  @_unavailableFromAsync(message: "Use async-safe scoped locking instead") func unlockWithCondition(_ condition: Int)
  @_unavailableFromAsync(message: "Use async-safe scoped locking instead") func lock(before limit: Date) -> Bool
  @available(swift, obsoleted: 3, renamed: "lock(before:)")
  @_unavailableFromAsync(message: "Use async-safe scoped locking instead") func lockBeforeDate(_ limit: Date) -> Bool
  @_unavailableFromAsync(message: "Use async-safe scoped locking instead") func lock(whenCondition condition: Int, before limit: Date) -> Bool
  @available(swift, obsoleted: 3, renamed: "lock(whenCondition:before:)")
  @_unavailableFromAsync(message: "Use async-safe scoped locking instead") func lockWhenCondition(_ condition: Int, beforeDate limit: Date) -> Bool
  @available(iOS 2.0, *)
  var name: String?
  convenience init()
  @_unavailableFromAsync(message: "Use async-safe scoped locking instead") func lock()
  @_unavailableFromAsync(message: "Use async-safe scoped locking instead") func unlock()
}
@_nonSendable(_assumed) class NSRecursiveLock : NSObject, NSLocking, @unchecked Sendable {
  @_unavailableFromAsync(message: "Use async-safe scoped locking instead") func `try`() -> Bool
  @available(swift, obsoleted: 3, renamed: "try()")
  @_unavailableFromAsync(message: "Use async-safe scoped locking instead") func tryLock() -> Bool
  @_unavailableFromAsync(message: "Use async-safe scoped locking instead") func lock(before limit: Date) -> Bool
  @available(swift, obsoleted: 3, renamed: "lock(before:)")
  @_unavailableFromAsync(message: "Use async-safe scoped locking instead") func lockBeforeDate(_ limit: Date) -> Bool
  @available(iOS 2.0, *)
  var name: String?
  init()
  @_unavailableFromAsync(message: "Use async-safe scoped locking instead") func lock()
  @_unavailableFromAsync(message: "Use async-safe scoped locking instead") func unlock()
}
@available(iOS 2.0, *)
@_nonSendable(_assumed) class NSCondition : NSObject, NSLocking, @unchecked Sendable {
  @_unavailableFromAsync(message: "Use async-safe scoped locking instead") func wait()
  @_unavailableFromAsync(message: "Use async-safe scoped locking instead") func wait(until limit: Date) -> Bool
  @available(swift, obsoleted: 3, renamed: "wait(until:)")
  @_unavailableFromAsync(message: "Use async-safe scoped locking instead") func waitUntilDate(_ limit: Date) -> Bool
  @_unavailableFromAsync(message: "Use async-safe scoped locking instead") func signal()
  func broadcast()
  @available(iOS 2.0, *)
  var name: String?
  init()
  @available(iOS 2.0, *)
  @_unavailableFromAsync(message: "Use async-safe scoped locking instead") func lock()
  @available(iOS 2.0, *)
  @_unavailableFromAsync(message: "Use async-safe scoped locking instead") func unlock()
}
