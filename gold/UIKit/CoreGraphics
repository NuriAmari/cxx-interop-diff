@_exported import CoreFoundation
@_exported import CoreGraphics.CGAffineTransform
@_exported import CoreGraphics.CGBase
@_exported import CoreGraphics.CGBitmapContext
@_exported import CoreGraphics.CGColor
@_exported import CoreGraphics.CGColorConversionInfo
@_exported import CoreGraphics.CGColorSpace
@_exported import CoreGraphics.CGContext
@_exported import CoreGraphics.CGConvertColorDataWithFormat
@_exported import CoreGraphics.CGDataConsumer
@_exported import CoreGraphics.CGDataProvider
@_exported import CoreGraphics.CGError
@_exported import CoreGraphics.CGFont
@_exported import CoreGraphics.CGFunction
@_exported import CoreGraphics.CGGeometry
@_exported import CoreGraphics.CGGradient
@_exported import CoreGraphics.CGImage
@_exported import CoreGraphics.CGLayer
@_exported import CoreGraphics.CGPDFArray
@_exported import CoreGraphics.CGPDFContentStream
@_exported import CoreGraphics.CGPDFContext
@_exported import CoreGraphics.CGPDFDictionary
@_exported import CoreGraphics.CGPDFDocument
@_exported import CoreGraphics.CGPDFObject
@_exported import CoreGraphics.CGPDFOperatorTable
@_exported import CoreGraphics.CGPDFPage
@_exported import CoreGraphics.CGPDFScanner
@_exported import CoreGraphics.CGPDFStream
@_exported import CoreGraphics.CGPDFString
@_exported import CoreGraphics.CGPath
@_exported import CoreGraphics.CGPattern
@_exported import CoreGraphics.CGShading
import Darwin
import _Concurrency
import _StringProcessing

@available(*, unavailable, message: "Use truncatingRemainder instead")
@_transparent func % (lhs: CGFloat, rhs: CGFloat) -> CGFloat

@available(*, unavailable, message: "Use formTruncatingRemainder instead")
@_transparent func %= (lhs: inout CGFloat, rhs: CGFloat)

@available(*, unavailable, message: "Use == instead")
func CGAffineTransformEqualToTransform(_ t1: CGAffineTransform, _ t2: CGAffineTransform) -> Bool

@available(*, unavailable, message: "Use == instead")
func CGColorEqualToColor(_ color1: CGColor?, _ color2: CGColor?) -> Bool

@available(*, unavailable, renamed: "getter:CGColor.components(self:)")
func CGColorGetComponents(_ color: CGColor?) -> UnsafePointer<CGFloat>

@available(*, unavailable, message: "Use class var white/black/clear instead")
func CGColorGetConstantColor(_ colorName: CFString?) -> CGColor?

@available(*, unavailable, renamed: "CGColorSpace.colorTable(self:_:)")
func CGColorSpaceGetColorTable(_ space: CGColorSpace?, _ table: UnsafeMutablePointer<UInt8>)

@available(*, unavailable, message: "Use colorTable.count instead")
func CGColorSpaceGetColorTableCount(_ space: CGColorSpace?) -> Int

@available(*, unavailable, message: "Use addArc(center:radius:startAngle:endAngle:clockwise:)")
func CGContextAddArc(_ c: CGContext?, _ x: CGFloat, _ y: CGFloat, _ radius: CGFloat, _ startAngle: CGFloat, _ endAngle: CGFloat, _ clockwise: Int32)

@available(*, unavailable, message: "Use addArc(self:x1:y1:x2:y2:radius:)")
func CGContextAddArcToPoint(_ c: CGContext?, _ x1: CGFloat, _ y1: CGFloat, _ x2: CGFloat, _ y2: CGFloat, _ radius: CGFloat)

@available(*, unavailable, message: "Use addCurve(to:control1:control2:) instead")
func CGContextAddCurveToPoint(_ c: CGContext?, _ cp1x: CGFloat, _ cp1y: CGFloat, _ cp2x: CGFloat, _ cp2y: CGFloat, _ x: CGFloat, _ y: CGFloat)

@available(*, unavailable, message: "Use addLine(to:) instead")
func CGContextAddLineToPoint(_ c: CGContext?, _ x: CGFloat, _ y: CGFloat)

@available(*, unavailable, message: "Use addLines(between:)")
func CGContextAddLines(_ c: CGContext?, _ points: UnsafePointer<CGPoint>, _ count: Int)

@available(*, unavailable, message: "Use addQuadCurve(to:control:)")
func CGContextAddQuadCurveToPoint(_ c: CGContext?, _ cpx: CGFloat, _ cpy: CGFloat, _ x: CGFloat, _ y: CGFloat)

@available(*, unavailable, message: "Use addRects(_:)")
func CGContextAddRects(_ c: CGContext?, _ rects: UnsafePointer<CGRect>, _ count: Int)

@available(*, unavailable, renamed: "CGContext.clip(self:)")
func CGContextClip(_ c: CGContext?)

@available(*, unavailable, message: "Use clip(to:)")
func CGContextClipToRects(_ c: CGContext?, _ rects: UnsafePointer<CGRect>, _ count: Int)

@available(*, unavailable, message: "Use draw(_:in:)")
func CGContextDrawImage(_ c: CGContext?, _ rect: CGRect, _ image: CGImage?)

@available(*, unavailable, message: "Use draw(_:at:)")
func CGContextDrawLayerAtPoint(_ context: CGContext?, _ point: CGPoint, _ layer: CGLayer?)

@available(*, unavailable, message: "Use draw(_:in:)")
func CGContextDrawLayerInRect(_ context: CGContext?, _ rect: CGRect, _ layer: CGLayer?)

@available(*, unavailable, message: "Use draw(_:in:byTiling:)")
func CGContextDrawTiledImage(_ c: CGContext?, _ rect: CGRect, _ image: CGImage?)

@available(*, unavailable, message: "Use clip(using:)")
func CGContextEOClip(_ c: CGContext?)

@available(*, unavailable, message: "Use fillPath(using:)")
func CGContextEOFillPath(_ c: CGContext?)

@available(*, unavailable, renamed: "CGContext.fillPath(self:)")
func CGContextFillPath(_ c: CGContext?)

@available(*, unavailable, message: "Use fill(self:_:count:)")
func CGContextFillRects(_ c: CGContext?, _ rects: UnsafePointer<CGRect>, _ count: Int)

@available(*, unavailable, renamed: "getter:CGContext.textPosition(self:)")
func CGContextGetTextPosition(_ c: CGContext?) -> CGPoint

@available(*, unavailable, message: "Use move(to:) instead")
func CGContextMoveToPoint(_ c: CGContext?, _ x: CGFloat, _ y: CGFloat)

@available(*, unavailable, message: "Use setLineDash(self:phase:lengths:)")
func CGContextSetLineDash(_ c: CGContext?, _ phase: CGFloat, _ lengths: UnsafePointer<CGFloat>, _ count: Int)

@available(*, unavailable, message: "Use var textPosition")
func CGContextSetTextPosition(_ c: CGContext?, _ x: CGFloat, _ y: CGFloat)

@available(*, unavailable, message: "Use showGlyphs(_:at:)")
func CGContextShowGlyphsAtPositions(_ c: CGContext?, _ glyphs: UnsafePointer<CGGlyph>, _ Lpositions: UnsafePointer<CGPoint>, _ count: Int)

@available(*, unavailable, message: "Use strokeLineSegments(self:between:count:)")
func CGContextStrokeLineSegments(_ c: CGContext?, _ points: UnsafePointer<CGPoint>, _ count: Int)

@available(*, unavailable, renamed: "CGFloat.greatestFiniteMagnitude")
var CGFLOAT_MAX: CGFloat { get }

@available(*, unavailable, renamed: "CGFloat.leastNormalMagnitude")
var CGFLOAT_MIN: CGFloat { get }

@available(*, unavailable, renamed: "CGGetLastMouseDelta")
func CGGetLastMouseDelta(_ deltaX: UnsafeMutablePointer<Int32>?, _ deltaY: UnsafeMutablePointer<Int32>?)

@available(*, unavailable, renamed: "CGImage.copy(self:maskingColorComponents:)")
func CGImageCreateWithMaskingColors(_ image: CGImage?, _ components: UnsafePointer<CGFloat>) -> CGImage?

@available(*, unavailable, message: "Use addArc(center:radius:startAngle:endAngle:clockwise:transform:)")
func CGPathAddArc(_ path: CGMutablePath?, _ m: UnsafePointer<CGAffineTransform>, _ x: CGFloat, _ y: CGFloat, _ radius: CGFloat, _ startAngle: CGFloat, _ endAngle: CGFloat, _ clockwise: Bool)

@available(*, unavailable, message: "Use addArc(tangent1End:tangent2End:radius:transform:)")
func CGPathAddArcToPoint(_ path: CGMutablePath?, _ m: UnsafePointer<CGAffineTransform>, _ x1: CGFloat, _ y1: CGFloat, _ x2: CGFloat, _ y2: CGFloat, _ radius: CGFloat)

@available(*, unavailable, message: "Use addCurve(to:control1:control2:transform:)")
func CGPathAddCurveToPoint(_ path: CGMutablePath?, _ m: UnsafePointer<CGAffineTransform>, _ cp1x: CGFloat, _ cp1y: CGFloat, _ cp2x: CGFloat, _ cp2y: CGFloat, _ x: CGFloat, _ y: CGFloat)

@available(*, unavailable, message: "Use addEllipse(rect:transform:)")
func CGPathAddEllipseInRect(_ path: CGMutablePath?, _ m: UnsafePointer<CGAffineTransform>, _ rect: CGRect)

@available(*, unavailable, message: "Use addLine(to:transform:)")
func CGPathAddLineToPoint(_ path: CGMutablePath?, _ m: UnsafePointer<CGAffineTransform>, _ x: CGFloat, _ y: CGFloat)

@available(*, unavailable, message: "Use addLines(between:transform:)")
func CGPathAddLines(_ path: CGMutablePath?, _ m: UnsafePointer<CGAffineTransform>, _ points: UnsafePointer<CGPoint>, _ count: Int)

@available(*, unavailable, message: "Use addPath(_:transform:)")
func CGPathAddPath(_ path1: CGMutablePath?, _ m: UnsafePointer<CGAffineTransform>, _ path2: CGPath?)

@available(*, unavailable, message: "Use addQuadCurve(to:control:transform:)")
func CGPathAddQuadCurveToPoint(_ path: CGMutablePath?, _ m: UnsafePointer<CGAffineTransform>, _ cpx: CGFloat, _ cpy: CGFloat, _ x: CGFloat, _ y: CGFloat)

@available(*, unavailable, message: "Use addRect(_:transform:)")
func CGPathAddRect(_ path: CGMutablePath?, _ m: UnsafePointer<CGAffineTransform>, _ rect: CGRect)

@available(*, unavailable, message: "Use addRects(_:transform:)")
func CGPathAddRects(_ path: CGMutablePath?, _ m: UnsafePointer<CGAffineTransform>, _ rects: UnsafePointer<CGRect>, _ count: Int)

@available(*, unavailable, message: "Use addRelativeArc(center:radius:startAngle:delta:transform:)")
func CGPathAddRelativeArc(_ path: CGMutablePath?, _ matrix: UnsafePointer<CGAffineTransform>, _ x: CGFloat, _ y: CGFloat, _ radius: CGFloat, _ startAngle: CGFloat, _ delta: CGFloat)

@available(*, unavailable, message: "Use copy(byDashingWithPhase:lengths:transform:)")
func CGPathCreateCopyByDashingPath(_ path: CGPath?, _ transform: UnsafePointer<CGAffineTransform>, _ phase: CGFloat, _ lengths: UnsafePointer<CGFloat>, _ count: Int) -> CGPath?

@available(*, unavailable, message: "Use copy(byStroking:lineWidth:lineCap:lineJoin:miterLimit:transform:)")
func CGPathCreateCopyByStrokingPath(_ path: CGPath?, _ transform: UnsafePointer<CGAffineTransform>, _ lineWidth: CGFloat, _ lineCap: CGLineCap, _ lineJoin: CGLineJoin, _ miterLimit: CGFloat) -> CGPath?

@available(*, unavailable, message: "Use == instead")
func CGPathEqualToPath(_ path1: CGPath?, _ path2: CGPath?) -> Bool

enum CGPathFillRule : Int {
  /// Nonzero winding number fill rule.
  /// 
  /// This rule plots a ray from the interior of the region to be evaluated
  /// toward the bounds of the drawing, and sums the closed path elements
  /// that the ray crosses: +1 for counterclockwise paths, -1 for clockwise.
  /// If the sum is zero, the region is left empty; if the sum is nonzero,
  /// the region is filled.
  case winding
  /// Even-Odd fill rule.
  /// 
  /// This rule plots a ray from the interior of the region to be evaluated
  /// toward the bounds of the drawing, and sums the closed path elements
  /// that the ray crosses.
  /// If the sum is an even numner, the region is left empty; if the sum is
  /// an odd number, the region is filled.
  case evenOdd
  init?(rawValue: Int)
  typealias RawValue = Int
  var rawValue: Int { get }
}

extension CGPathFillRule : Equatable {
}

extension CGPathFillRule : Hashable {
}

extension CGPathFillRule : RawRepresentable {
}

@available(*, unavailable, message: "Use move(to:transform:)")
func CGPathMoveToPoint(_ path: CGMutablePath?, _ m: UnsafePointer<CGAffineTransform>, _ x: CGFloat, _ y: CGFloat)

@available(*, unavailable, message: "Use CGPoint.init(dictionaryRepresentation:)")
func CGPointMakeWithDictionaryRepresentation(_ dict: CFDictionary?, _ point: UnsafeMutablePointer<CGPoint>) -> Bool

@available(*, unavailable, message: "Use divided(atDistance:from:)")
func CGRectDivide(_ rect: CGRect, _ slice: UnsafeMutablePointer<CGRect>, _ remainder: UnsafeMutablePointer<CGRect>, _ amount: CGFloat, _ edge: CGRectEdge)

@available(*, unavailable, message: "Use CGRect.init(dictionaryRepresentation:)")
func CGRectMakeWithDictionaryRepresentation(_ dict: CFDictionary?, _ rect: UnsafeMutablePointer<CGRect>) -> Bool

@available(*, unavailable, message: "Use CGSize.init(dictionaryRepresentation:)")
func CGSizeMakeWithDictionaryRepresentation(_ dict: CFDictionary?, _ size: UnsafeMutablePointer<CGSize>) -> Bool

protocol _CGColorInitTrampoline {
  init?(colorSpace space: CGColorSpace, components: UnsafePointer<CGFloat>)
}

extension _CGColorInitTrampoline {
  init(_colorLiteralRed red: Float, green: Float, blue: Float, alpha: Float)
}

@_alwaysEmitIntoClient func __CGAffineTransformMake(_ a: CGFloat, _ b: CGFloat, _ c: CGFloat, _ d: CGFloat, _ tx: CGFloat, _ ty: CGFloat) -> CGAffineTransform

@_alwaysEmitIntoClient func __CGPointApplyAffineTransform(_ point: CGPoint, _ t: CGAffineTransform) -> CGPoint

@_alwaysEmitIntoClient func __CGSizeApplyAffineTransform(_ size: CGSize, _ t: CGAffineTransform) -> CGSize

@_transparent func acos(_ x: CGFloat) -> CGFloat

@_transparent func acosh(_ x: CGFloat) -> CGFloat

@_transparent func asin(_ x: CGFloat) -> CGFloat

@_transparent func asinh(_ x: CGFloat) -> CGFloat

@_transparent func atan(_ x: CGFloat) -> CGFloat

@_transparent func atan2(_ lhs: CGFloat, _ rhs: CGFloat) -> CGFloat

@_transparent func atanh(_ x: CGFloat) -> CGFloat

@_transparent func cbrt(_ x: CGFloat) -> CGFloat

@_transparent func copysign(_ lhs: CGFloat, _ rhs: CGFloat) -> CGFloat

@_transparent func cos(_ x: CGFloat) -> CGFloat

@_transparent func cosh(_ x: CGFloat) -> CGFloat

@_transparent func erf(_ x: CGFloat) -> CGFloat

@_transparent func erfc(_ x: CGFloat) -> CGFloat

@_transparent func exp(_ x: CGFloat) -> CGFloat

@_transparent func exp2(_ x: CGFloat) -> CGFloat

@_transparent func expm1(_ x: CGFloat) -> CGFloat

@_transparent func fdim(_ lhs: CGFloat, _ rhs: CGFloat) -> CGFloat

@_transparent func fmax(_ lhs: CGFloat, _ rhs: CGFloat) -> CGFloat

@_transparent func fmin(_ lhs: CGFloat, _ rhs: CGFloat) -> CGFloat

@available(*, unavailable, message: "use the floatingPointClass property.")
@_transparent func fpclassify(_ x: CGFloat) -> Int

@_transparent func hypot(_ lhs: CGFloat, _ rhs: CGFloat) -> CGFloat

@available(swift, deprecated: 4.2, message: "use the exponent property.")
@_transparent func ilogb(_ x: CGFloat) -> Int

@available(*, unavailable, message: "use the isFinite property.")
func isfinite(_ value: CGFloat) -> Bool

@available(*, unavailable, message: "use the isInfinite property.")
func isinf(_ value: CGFloat) -> Bool

@available(*, unavailable, message: "use the isNaN property.")
func isnan(_ value: CGFloat) -> Bool

@available(*, unavailable, message: "use the isNormal property.")
func isnormal(_ value: CGFloat) -> Bool

@_transparent func j0(_ x: CGFloat) -> CGFloat

@_transparent func j1(_ x: CGFloat) -> CGFloat

@_transparent func jn(_ n: Int, _ x: CGFloat) -> CGFloat

@available(*, unavailable, message: "Use CGColor.black")
var kCGColorBlack: CFString { get }

@available(*, unavailable, message: "Use CGColor.clear")
var kCGColorClear: CFString { get }

@available(*, unavailable, message: "Use CGColor.white")
var kCGColorWhite: CFString { get }

@available(swift, deprecated: 4.2, renamed: "scalbn")
@_transparent func ldexp(_ x: CGFloat, _ n: Int) -> CGFloat

@_transparent func lgamma(_ x: CGFloat) -> (CGFloat, Int)

@_transparent func log(_ x: CGFloat) -> CGFloat

@_transparent func log10(_ x: CGFloat) -> CGFloat

@_transparent func log1p(_ x: CGFloat) -> CGFloat

@_transparent func log2(_ x: CGFloat) -> CGFloat

@_transparent func logb(_ x: CGFloat) -> CGFloat

@available(swift, deprecated: 4.2, message: "use CGFloat(nan: CGFloat.RawSignificand) instead.")
@_transparent func nan(_ tag: String) -> CGFloat

@_transparent func nearbyint(_ x: CGFloat) -> CGFloat

@_transparent func nextafter(_ lhs: CGFloat, _ rhs: CGFloat) -> CGFloat

@_transparent func pow(_ lhs: CGFloat, _ rhs: CGFloat) -> CGFloat

@_transparent func remquo(_ x: CGFloat, _ y: CGFloat) -> (CGFloat, Int)

@_transparent func rint(_ x: CGFloat) -> CGFloat

@available(*, unavailable, message: "use the sign property.")
func signbit(_ value: CGFloat) -> Int

@_transparent func sin(_ x: CGFloat) -> CGFloat

@_transparent func sinh(_ x: CGFloat) -> CGFloat

@_transparent func tan(_ x: CGFloat) -> CGFloat

@_transparent func tanh(_ x: CGFloat) -> CGFloat

@_transparent func tgamma(_ x: CGFloat) -> CGFloat

@_transparent func y0(_ x: CGFloat) -> CGFloat

@_transparent func y1(_ x: CGFloat) -> CGFloat

@_transparent func yn(_ n: Int, _ x: CGFloat) -> CGFloat

extension CGFloat {
  @available(*, unavailable, renamed: "leastNormalMagnitude")
  static var min: CGFloat { get }
  @available(*, unavailable, renamed: "greatestFiniteMagnitude")
  static var max: CGFloat { get }
}

extension CGAffineTransform : Equatable {
  static func == (lhs: CGAffineTransform, rhs: CGAffineTransform) -> Bool
}

extension CGColor {
  @available(macOS 10.3, iOS 2.0, *)
  var components: [CGFloat]? { get }
}

extension CGColor : _CGColorInitTrampoline, _ExpressibleByColorLiteral {
}

extension CGColor : @unchecked Sendable {
}

extension CGColorSpace {
  var colorTable: [UInt8]? { get }
}

extension CGColorSpace : @unchecked Sendable {
}

extension CGContext {
  func setLineDash(phase: CGFloat, lengths: [CGFloat])
  func move(to point: CGPoint)
  func addLine(to point: CGPoint)
  func addCurve(to end: CGPoint, control1: CGPoint, control2: CGPoint)
  func addQuadCurve(to end: CGPoint, control: CGPoint)
  func addRects(_ rects: [CGRect])
  func addLines(between points: [CGPoint])
  func addArc(center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)
  func addArc(tangent1End: CGPoint, tangent2End: CGPoint, radius: CGFloat)
  /// Fills the current path using the specified rule (winding by default).
  ///
  /// Any open subpath is implicitly closed.
  func fillPath(using rule: CGPathFillRule = .winding)
  /// Intersects the current path with the current clipping region and uses the
  /// result as the new clipping region for subsequent drawing.
  ///
  /// Uses the specified fill rule (winding by default) to determine which
  /// areas to treat as the interior of the clipping region. When evaluating
  /// the path, any open subpath is implicitly closed.
  func clip(using rule: CGPathFillRule = .winding)
  func fill(_ rects: [CGRect])
  func strokeLineSegments(between points: [CGPoint])
  func clip(to rects: [CGRect])
  func draw(_ image: CGImage, in rect: CGRect, byTiling: Bool = false)
  var textPosition: CGPoint
  func showGlyphs(_ glyphs: [CGGlyph], at positions: [CGPoint])
}

extension CGPoint {
  static var zero: CGPoint { get }
  @_transparent init(x: Int, y: Int)
  @_transparent init(x: Double, y: Double)
  init?(dictionaryRepresentation dict: CFDictionary)
}

extension CGPoint : CustomReflectable {
  var customMirror: Mirror { get }
}

extension CGPoint : _CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "CGPoint.customPlaygroundQuickLook will be removed in a future Swift version")
  var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension CGPoint : CustomDebugStringConvertible {
  var debugDescription: String { get }
}

extension CGPoint : Equatable {
  @_transparent static func == (lhs: CGPoint, rhs: CGPoint) -> Bool
}

extension CGPoint : Codable {
  init(from decoder: Decoder) throws
  func encode(to encoder: Encoder) throws
}

extension CGSize {
  static var zero: CGSize { get }
  @_transparent init(width: Int, height: Int)
  @_transparent init(width: Double, height: Double)
  init?(dictionaryRepresentation dict: CFDictionary)
}

extension CGSize : CustomReflectable {
  var customMirror: Mirror { get }
}

extension CGSize : _CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "CGSize.customPlaygroundQuickLook will be removed in a future Swift version")
  var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension CGSize : CustomDebugStringConvertible {
  var debugDescription: String { get }
}

extension CGSize : Equatable {
  @_transparent static func == (lhs: CGSize, rhs: CGSize) -> Bool
}

extension CGSize : Codable {
  init(from decoder: Decoder) throws
  func encode(to encoder: Encoder) throws
}

extension CGVector {
  static var zero: CGVector { get }
  @_transparent init(dx: Int, dy: Int)
  @_transparent init(dx: Double, dy: Double)
}

extension CGVector : Equatable {
  @_transparent static func == (lhs: CGVector, rhs: CGVector) -> Bool
}

extension CGVector : CustomDebugStringConvertible {
  var debugDescription: String { get }
}

extension CGVector : Codable {
  init(from decoder: Decoder) throws
  func encode(to encoder: Encoder) throws
}

extension CGRect {
  static var zero: CGRect { get }
  @_transparent init(x: CGFloat, y: CGFloat, width: CGFloat, height: CGFloat)
  @_transparent init(x: Double, y: Double, width: Double, height: Double)
  @_transparent init(x: Int, y: Int, width: Int, height: Int)
  init?(dictionaryRepresentation dict: CFDictionary)
  @_transparent func divided(atDistance: CGFloat, from fromEdge: CGRectEdge) -> (slice: CGRect, remainder: CGRect)
  @available(*, unavailable, renamed: "minX")
  var x: CGFloat { get }
  @available(*, unavailable, renamed: "minY")
  var y: CGFloat { get }
}

extension CGRect : CustomReflectable {
  var customMirror: Mirror { get }
}

extension CGRect : _CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "CGRect.customPlaygroundQuickLook will be removed in a future Swift version")
  var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension CGRect : CustomDebugStringConvertible {
  var debugDescription: String { get }
}

extension CGRect : Equatable {
  @_transparent static func == (lhs: CGRect, rhs: CGRect) -> Bool
}

extension CGRect : Codable {
  init(from decoder: Decoder) throws
  func encode(to encoder: Encoder) throws
}

extension CGAffineTransform {
  static var identity: CGAffineTransform { get }
}

extension CGAffineTransform : Codable {
  init(from decoder: Decoder) throws
  func encode(to encoder: Encoder) throws
}

extension CGImage {
  func copy(maskingColorComponents components: [CGFloat]) -> CGImage?
}

extension CGImage : @unchecked Sendable {
}

extension CGContext {
  func draw(_ layer: CGLayer, in rect: CGRect)
  func draw(_ layer: CGLayer, at point: CGPoint)
}

extension CGPath {
  func copy(dashingWithPhase phase: CGFloat, lengths: [CGFloat], transform: CGAffineTransform = .identity) -> CGPath
  func copy(strokingWithWidth lineWidth: CGFloat, lineCap: CGLineCap, lineJoin: CGLineJoin, miterLimit: CGFloat, transform: CGAffineTransform = .identity) -> CGPath
  func contains(_ point: CGPoint, using rule: CGPathFillRule = .winding, transform: CGAffineTransform = .identity) -> Bool
}

extension CGMutablePath {
  func addRoundedRect(in rect: CGRect, cornerWidth: CGFloat, cornerHeight: CGFloat, transform: CGAffineTransform = .identity)
  func move(to point: CGPoint, transform: CGAffineTransform = .identity)
  func addLine(to point: CGPoint, transform: CGAffineTransform = .identity)
  func addQuadCurve(to end: CGPoint, control: CGPoint, transform: CGAffineTransform = .identity)
  func addCurve(to end: CGPoint, control1: CGPoint, control2: CGPoint, transform: CGAffineTransform = .identity)
  func addRect(_ rect: CGRect, transform: CGAffineTransform = .identity)
  func addRects(_ rects: [CGRect], transform: CGAffineTransform = .identity)
  func addLines(between points: [CGPoint], transform: CGAffineTransform = .identity)
  func addEllipse(in rect: CGRect, transform: CGAffineTransform = .identity)
  func addRelativeArc(center: CGPoint, radius: CGFloat, startAngle: CGFloat, delta: CGFloat, transform: CGAffineTransform = .identity)
  func addArc(center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool, transform: CGAffineTransform = .identity)
  func addArc(tangent1End: CGPoint, tangent2End: CGPoint, radius: CGFloat, transform: CGAffineTransform = .identity)
  func addPath(_ path: CGPath, transform: CGAffineTransform = .identity)
}

@available(iOS 16.0, macOS 13.0, tvOS 16.0, watchOS 9.0, *)
extension CGPath {
  /// Returns a new path with filled regions in either this path or the given path.
  /// - Parameters:
  ///   - other: The path to union.
  ///   - rule: The rule for determining which areas to treat as the interior of the paths.
  ///     Defaults to the `CGPathFillRule.winding` rule if not specified.
  /// - Returns: A new path.
  ///
  /// The filled region of resulting path is the combination of the filled region of both paths added together.
  ///
  /// Any unclosed subpaths in either path are assumed to be closed. The result of filling this
  /// path using either even-odd or non-zero fill rules is identical.
  func union(_ other: CGPath, using rule: CGPathFillRule = .winding) -> CGPath
  /// Returns a new path with filled regions common to both paths.
  /// - Parameters:
  ///   - other: The path to intersect.
  ///   - rule: The rule for determining which areas to treat as the interior of the paths.
  ///     Defaults to the `CGPathFillRule.winding` rule if not specified.
  /// - Returns: A new path.
  ///
  /// The filled region of the resulting path is the overlapping area of the filled region of both paths.
  /// This can be used to clip the fill of a path to a mask.
  ///
  /// Any unclosed subpaths in either path are assumed to be closed. The result of filling this
  /// path using either even-odd or non-zero fill rules is identical.
  func intersection(_ other: CGPath, using rule: CGPathFillRule = .winding) -> CGPath
  /// Returns a new path with filled regions from this path that are not in the given path.
  /// - Parameters:
  ///   - other: The path to subtract.
  ///   - rule: The rule for determining which areas to treat as the interior of the paths.
  ///     Defaults to the `CGPathFillRule.winding` rule if not specified.
  /// - Returns: A new path.
  ///
  /// The filled region of the resulting path is the filled region of this path with the filled
  /// region `other` removed from it.
  ///
  /// Any unclosed subpaths in either path are assumed to be closed. The result of filling this
  /// path using either even-odd or non-zero fill rules is identical.
  func subtracting(_ other: CGPath, using rule: CGPathFillRule = .winding) -> CGPath
  /// Returns a new path with filled regions either from this path or the given path, but not in both.
  /// - Parameters:
  ///   - other: The path to difference.
  ///   - rule: The rule for determining which areas to treat as the interior of the paths.
  ///     Defaults to the `CGPathFillRule.winding` rule if not specified.
  /// - Returns: A new path.
  ///
  /// The filled region of the resulting path is the filled region contained in either this path
  /// or `other`, but not both.
  ///
  /// Any unclosed subpaths in either path are assumed to be closed. The result of filling this
  /// path using either even-odd or non-zero fill rules is identical.
  func symmetricDifference(_ other: CGPath, using rule: CGPathFillRule = .winding) -> CGPath
  /// Returns a new path with a line from this path that does not overlap the filled region of the given path.
  /// - Parameters:
  ///   - other: The path to subtract.
  ///   - rule: The rule for determining which areas to treat as the interior of `other`.
  ///     Defaults to the `CGPathFillRule.winding` rule if not specified.
  /// - Returns: A new path.
  ///
  /// The line of the resulting path is the line of this path that does not overlap the filled region of `other`.
  ///
  /// Intersected subpaths that are clipped create open subpaths. Closed subpaths that do not
  /// intersect `other` remain closed.
  func lineSubtracting(_ other: CGPath, using rule: CGPathFillRule = .winding) -> CGPath
  /// Returns a new path with a line from this path that overlaps the filled regions of the given path.
  /// - Parameters:
  ///   - other: The path to intersect.
  ///   - rule: The rule for determining which areas to treat as the interior of `other`.
  ///     Defaults to the `CGPathFillRule.winding` rule if not specified.
  /// - Returns: A new path.
  ///
  /// The line of the resulting path is the line of this path that overlaps the filled region of `other`.
  ///
  /// Intersected subpaths that are clipped create open subpaths. Closed subpaths that do not
  /// intersect `other` remain closed.
  func lineIntersection(_ other: CGPath, using rule: CGPathFillRule = .winding) -> CGPath
  /// Returns a new weakly-simple copy of this path.
  /// - Parameter rule: The rule for determining which areas to treat as the interior of the path.
  ///   Defaults to the `CGPathFillRule.winding` rule if not specified.
  /// - Returns: A new path.
  ///
  /// The returned path is weakly-simple path, has no self-intersections, and has a normalized
  /// orientation. The result of filling this path using either even-odd or non-zero fill rules
  /// is identical.
  func normalized(using rule: CGPathFillRule = .winding) -> CGPath
  /// Returns a flattened copy of this path.
  /// - Parameter threshold: The maximum error tolerance.
  /// - Returns: A new path.
  ///
  /// The granularity of the approximation is controlled by `threshold` the maximum error
  /// tolerance (measured in points) for curves.
  func flattened(threshold: CGFloat) -> CGPath
  /// Returns whether paths overlap.
  /// - Parameters:
  ///   - other: The path to check for intersection.
  ///   - rule: The rule for determining which areas to treat as the interior of the paths.
  ///     Defaults to the `CGPathFillRule.winding` rule if not specified.
  /// - Returns: `true` if the paths intersect.
  ///
  /// This is the same as testing if the intersection of two paths is not empty. That is, the
  /// filled areas of the paths overlap. Open subpaths are treated as closed subpaths, the same
  /// as when filling a path in a `CGContext`.
  func intersects(_ other: CGPath, using rule: CGPathFillRule = .winding) -> Bool
  /// Return an array of the visually separated components of a path.
  /// - Parameter rule: The rule for determining which areas to treat as the interior of the path.
  ///   Defaults to the `CGPathFillRule.winding` rule if not specified.
  /// - Returns: The visually separate components.
  ///
  /// Separating components of a path returns the components from splitting the path into multiple
  /// distinct paths. Rendered individually the components look the same as the original path.
  /// This can be used to break a single path (eg. a symbol) into its component pieces so that each
  /// component can be colored separately.
  func componentsSeparated(using rule: CGPathFillRule = .winding) -> [CGPath]
}

extension CGAffineTransform {
  @_alwaysEmitIntoClient init(translationX tx: CGFloat, y ty: CGFloat)
  @_alwaysEmitIntoClient init(scaleX sx: CGFloat, y sy: CGFloat)
  @_alwaysEmitIntoClient init(rotationAngle angle: CGFloat)
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient init(_ components: CGAffineTransformComponents)
  @_alwaysEmitIntoClient var isIdentity: Bool { get }
  @_alwaysEmitIntoClient func translatedBy(x tx: CGFloat, y ty: CGFloat) -> CGAffineTransform
  @_alwaysEmitIntoClient func scaledBy(x sx: CGFloat, y sy: CGFloat) -> CGAffineTransform
  @_alwaysEmitIntoClient func rotated(by angle: CGFloat) -> CGAffineTransform
  @_alwaysEmitIntoClient func inverted() -> CGAffineTransform
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient func decomposed() -> CGAffineTransformComponents
  @_alwaysEmitIntoClient func concatenating(_ t2: CGAffineTransform) -> CGAffineTransform
}

extension CGAffineTransformComponents {
  @available(macOS 13.0, iOS 16.0, watchOS 9.0, tvOS 16.0, *)
  @_alwaysEmitIntoClient init(scale: CGSize = .init(width: 1, height: 1), horizontalShear: CGFloat = 0, rotation: CGFloat = 0, translation: CGVector = .zero)
}

extension CGPoint {
  @_alwaysEmitIntoClient func applying(_ t: CGAffineTransform) -> CGPoint
}

extension CGSize {
  @_alwaysEmitIntoClient func applying(_ t: CGAffineTransform) -> CGSize
}

extension CGRect {
  @_alwaysEmitIntoClient func applying(_ t: CGAffineTransform) -> CGRect
}

/*** Definitions of inline functions. ***/
extension CGAffineTransform {
  @_alwaysEmitIntoClient init(_ a: CGFloat, _ b: CGFloat, _ c: CGFloat, _ d: CGFloat, _ tx: CGFloat, _ ty: CGFloat)
}

extension CGPoint {
  @_alwaysEmitIntoClient func equalTo(_ point2: CGPoint) -> Bool
  /*** Persistent representations. ***/
  @_alwaysEmitIntoClient var dictionaryRepresentation: CFDictionary { get }
}

extension CGSize {
  @_alwaysEmitIntoClient func equalTo(_ size2: CGSize) -> Bool
  @_alwaysEmitIntoClient var dictionaryRepresentation: CFDictionary { get }
}

extension CGRect {
  @_transparent func __divided(slice: UnsafeMutablePointer<CGRect>, remainder: UnsafeMutablePointer<CGRect>, atDistance: CGFloat, from: CGRectEdge)
  @_alwaysEmitIntoClient static var null: CGRect { get }
  @_alwaysEmitIntoClient static var infinite: CGRect { get }
  @_alwaysEmitIntoClient var minX: CGFloat { get }
  @_alwaysEmitIntoClient var midX: CGFloat { get }
  @_alwaysEmitIntoClient var maxX: CGFloat { get }
  @_alwaysEmitIntoClient var minY: CGFloat { get }
  @_alwaysEmitIntoClient var midY: CGFloat { get }
  @_alwaysEmitIntoClient var maxY: CGFloat { get }
  @_alwaysEmitIntoClient var width: CGFloat { get }
  @_alwaysEmitIntoClient var height: CGFloat { get }
  @_alwaysEmitIntoClient func equalTo(_ rect2: CGRect) -> Bool
  @_alwaysEmitIntoClient var standardized: CGRect { get }
  @_alwaysEmitIntoClient var isEmpty: Bool { get }
  @_alwaysEmitIntoClient var isNull: Bool { get }
  @_alwaysEmitIntoClient var isInfinite: Bool { get }
  @_alwaysEmitIntoClient func insetBy(dx: CGFloat, dy: CGFloat) -> CGRect
  @_alwaysEmitIntoClient var integral: CGRect { get }
  @_alwaysEmitIntoClient func union(_ r2: CGRect) -> CGRect
  @_alwaysEmitIntoClient func intersection(_ r2: CGRect) -> CGRect
  @_alwaysEmitIntoClient func offsetBy(dx: CGFloat, dy: CGFloat) -> CGRect
  @_alwaysEmitIntoClient func contains(_ point: CGPoint) -> Bool
  @_alwaysEmitIntoClient func contains(_ rect2: CGRect) -> Bool
  @_alwaysEmitIntoClient func intersects(_ rect2: CGRect) -> Bool
  @_alwaysEmitIntoClient var dictionaryRepresentation: CFDictionary { get }
}

@available(*, unavailable, renamed: "CGFloat.leastNormalMagnitude")
let CGFLOAT_MIN: CGFloat { get }

@available(*, unavailable, renamed: "CGFloat.greatestFiniteMagnitude")
let CGFLOAT_MAX: CGFloat { get }

@available(*, unavailable, message: "Use CGColor.white")
let kCGColorWhite: CFString { get }

@available(*, unavailable, message: "Use CGColor.black")
let kCGColorBlack: CFString { get }

@available(*, unavailable, message: "Use CGColor.clear")
let kCGColorClear: CFString { get }

