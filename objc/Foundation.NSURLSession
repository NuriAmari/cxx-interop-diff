@_exported import CoreFoundation

@available(iOS 7.0, *)
let NSURLSessionTransferSizeUnknown: Int64
@available(iOS 7.0, *)
@available(swift, obsoleted: 3, renamed: "URLSession")
typealias NSURLSession = URLSession
@available(iOS 7.0, *)
class URLSession : NSObject {
  class var shared: URLSession { get }
  @available(swift, obsoleted: 3, renamed: "shared")
  class var sharedSession: URLSession { get }
  /*not inherited*/ init(configuration: URLSessionConfiguration)
  @available(*, unavailable, renamed: "init(configuration:)", message: "Not available in Swift")
  class func sessionWithConfiguration(_ configuration: URLSessionConfiguration) -> URLSession
  /*not inherited*/ init(configuration: URLSessionConfiguration, delegate: URLSessionDelegate?, delegateQueue queue: OperationQueue?)
  @available(*, unavailable, renamed: "init(configuration:delegate:delegateQueue:)", message: "Not available in Swift")
  class func sessionWithConfiguration(_ configuration: URLSessionConfiguration, delegate: URLSessionDelegate?, delegateQueue queue: OperationQueue?) -> URLSession
  var delegateQueue: OperationQueue { get }
  var delegate: URLSessionDelegate? { get }
  @NSCopying var configuration: URLSessionConfiguration { get }
  var sessionDescription: String?
  func finishTasksAndInvalidate()
  func invalidateAndCancel()
  func reset(completionHandler: @escaping @Sendable () -> Void)
  func reset() async
  @available(swift, obsoleted: 3, renamed: "reset(completionHandler:)")
  func resetWithCompletionHandler(_ completionHandler: @escaping @Sendable () -> Void)
  func flush(completionHandler: @escaping @Sendable () -> Void)
  func flush() async
  @available(swift, obsoleted: 3, renamed: "flush(completionHandler:)")
  func flushWithCompletionHandler(_ completionHandler: @escaping @Sendable () -> Void)
  func getTasksWithCompletionHandler(_ completionHandler: @escaping @Sendable ([URLSessionDataTask], [URLSessionUploadTask], [URLSessionDownloadTask]) -> Void)
  var tasks: ([URLSessionDataTask], [URLSessionUploadTask], [URLSessionDownloadTask]) { get async }
  @available(iOS 9.0, *)
  func getAllTasks(completionHandler: @escaping @Sendable ([URLSessionTask]) -> Void)
  @available(iOS 9.0, *)
  var allTasks: [URLSessionTask] { get async }
  @available(iOS 9.0, *)
  @available(swift, obsoleted: 3, renamed: "getAllTasks(completionHandler:)")
  func getAllTasksWithCompletionHandler(_ completionHandler: @escaping @Sendable ([URLSessionTask]) -> Void)
  func dataTask(with request: URLRequest) -> URLSessionDataTask
  @available(swift, obsoleted: 3, renamed: "dataTask(with:)")
  func dataTaskWithRequest(_ request: URLRequest) -> URLSessionDataTask
  func dataTask(with url: URL) -> URLSessionDataTask
  @available(swift, obsoleted: 3, renamed: "dataTask(with:)")
  func dataTaskWithURL(_ url: URL) -> URLSessionDataTask
  func uploadTask(with request: URLRequest, fromFile fileURL: URL) -> URLSessionUploadTask
  @available(swift, obsoleted: 3, renamed: "uploadTask(with:fromFile:)")
  func uploadTaskWithRequest(_ request: URLRequest, fromFile fileURL: URL) -> URLSessionUploadTask
  func uploadTask(with request: URLRequest, from bodyData: Data) -> URLSessionUploadTask
  @available(swift, obsoleted: 3, renamed: "uploadTask(with:from:)")
  func uploadTaskWithRequest(_ request: URLRequest, fromData bodyData: Data) -> URLSessionUploadTask
  func uploadTask(withStreamedRequest request: URLRequest) -> URLSessionUploadTask
  @available(swift, obsoleted: 3, renamed: "uploadTask(withStreamedRequest:)")
  func uploadTaskWithStreamedRequest(_ request: URLRequest) -> URLSessionUploadTask
  func downloadTask(with request: URLRequest) -> URLSessionDownloadTask
  @available(swift, obsoleted: 3, renamed: "downloadTask(with:)")
  func downloadTaskWithRequest(_ request: URLRequest) -> URLSessionDownloadTask
  func downloadTask(with url: URL) -> URLSessionDownloadTask
  @available(swift, obsoleted: 3, renamed: "downloadTask(with:)")
  func downloadTaskWithURL(_ url: URL) -> URLSessionDownloadTask
  func downloadTask(withResumeData resumeData: Data) -> URLSessionDownloadTask
  @available(swift, obsoleted: 3, renamed: "downloadTask(withResumeData:)")
  func downloadTaskWithResumeData(_ resumeData: Data) -> URLSessionDownloadTask
  @available(iOS 9.0, *)
  func streamTask(withHostName hostname: String, port: Int) -> URLSessionStreamTask
  @available(iOS 9.0, *)
  @available(swift, obsoleted: 3, renamed: "streamTask(withHostName:port:)")
  func streamTaskWithHostName(_ hostname: String, port: Int) -> URLSessionStreamTask
  @available(iOS, introduced: 9.0, deprecated: 100000, message: "Use nw_connection_t in Network framework instead")
  func streamTask(with service: NetService) -> URLSessionStreamTask
  @available(swift, obsoleted: 3, renamed: "streamTask(with:)")
  @available(iOS, introduced: 9.0, deprecated: 100000, message: "Use nw_connection_t in Network framework instead")
  func streamTaskWithNetService(_ service: NetService) -> URLSessionStreamTask
  @available(iOS 13.0, *)
  func webSocketTask(with url: URL) -> URLSessionWebSocketTask
  @available(iOS 13.0, *)
  @available(swift, obsoleted: 3, renamed: "webSocketTask(with:)")
  func webSocketTaskWithURL(_ url: URL) -> URLSessionWebSocketTask
  @available(iOS 13.0, *)
  func webSocketTask(with url: URL, protocols: [String]) -> URLSessionWebSocketTask
  @available(iOS 13.0, *)
  @available(swift, obsoleted: 3, renamed: "webSocketTask(with:protocols:)")
  func webSocketTaskWithURL(_ url: URL, protocols: [String]) -> URLSessionWebSocketTask
  @available(iOS 13.0, *)
  func webSocketTask(with request: URLRequest) -> URLSessionWebSocketTask
  @available(iOS 13.0, *)
  @available(swift, obsoleted: 3, renamed: "webSocketTask(with:)")
  func webSocketTaskWithRequest(_ request: URLRequest) -> URLSessionWebSocketTask
  @available(iOS, introduced: 7.0, deprecated: 13.0, message: "Please use +[NSURLSession sessionWithConfiguration:] or other class methods to create instances")
  init()
  @available(iOS, introduced: 7.0, deprecated: 13.0, message: "Please use +[NSURLSession sessionWithConfiguration:] or other class methods to create instances")
  class func new() -> Self
}

extension URLSession {
  @_alwaysEmitIntoClient func makeState() -> ManagedBuffer<(isCancelled: Bool, task: URLSessionTask?), os_unfair_lock>
  @_alwaysEmitIntoClient func cancel(state: ManagedBuffer<(isCancelled: Bool, task: URLSessionTask?), os_unfair_lock>)
  @_alwaysEmitIntoClient func activate(state: ManagedBuffer<(isCancelled: Bool, task: URLSessionTask?), os_unfair_lock>, task: URLSessionTask)
}

@available(macOS 12.0, iOS 15.0, watchOS 8.0, tvOS 15.0, *)
extension URLSession {
  /// Convenience method to load data using an URLRequest, creates and resumes an URLSessionDataTask internally.
  ///
  /// - Parameter request: The URLRequest for which to load data.
  /// - Parameter delegate: Task-specific delegate.
  /// - Returns: Data and response.
  func data(for request: URLRequest, delegate: URLSessionTaskDelegate? = nil) async throws -> (Data, URLResponse)
  /// Convenience method to load data using an URL, creates and resumes an URLSessionDataTask internally.
  ///
  /// - Parameter url: The URL for which to load data.
  /// - Parameter delegate: Task-specific delegate.
  /// - Returns: Data and response.
  func data(from url: URL, delegate: URLSessionTaskDelegate? = nil) async throws -> (Data, URLResponse)
  /// Convenience method to upload data using an URLRequest, creates and resumes an URLSessionUploadTask internally.
  ///
  /// - Parameter request: The URLRequest for which to upload data.
  /// - Parameter fileURL: File to upload.
  /// - Parameter delegate: Task-specific delegate.
  /// - Returns: Data and response.
  func upload(for request: URLRequest, fromFile fileURL: URL, delegate: URLSessionTaskDelegate? = nil) async throws -> (Data, URLResponse)
  /// Convenience method to upload data using an URLRequest, creates and resumes an URLSessionUploadTask internally.
  ///
  /// - Parameter request: The URLRequest for which to upload data.
  /// - Parameter bodyData: Data to upload.
  /// - Parameter delegate: Task-specific delegate.
  /// - Returns: Data and response.
  func upload(for request: URLRequest, from bodyData: Data, delegate: URLSessionTaskDelegate? = nil) async throws -> (Data, URLResponse)
  /// Convenience method to download using an URLRequest, creates and resumes an URLSessionDownloadTask internally.
  ///
  /// - Parameter request: The URLRequest for which to download.
  /// - Parameter delegate: Task-specific delegate.
  /// - Returns: Downloaded file URL and response. The file will not be removed automatically.
  func download(for request: URLRequest, delegate: URLSessionTaskDelegate? = nil) async throws -> (URL, URLResponse)
  /// Convenience method to download using an URL, creates and resumes an URLSessionDownloadTask internally.
  ///
  /// - Parameter url: The URL for which to download.
  /// - Parameter delegate: Task-specific delegate.
  /// - Returns: Downloaded file URL and response. The file will not be removed automatically.
  func download(from url: URL, delegate: URLSessionTaskDelegate? = nil) async throws -> (URL, URLResponse)
  /// Convenience method to resume download, creates and resumes an URLSessionDownloadTask internally.
  ///
  /// - Parameter resumeData: Resume data from an incomplete download.
  /// - Parameter delegate: Task-specific delegate.
  /// - Returns: Downloaded file URL and response. The file will not be removed automatically.
  func download(resumeFrom resumeData: Data, delegate: URLSessionTaskDelegate? = nil) async throws -> (URL, URLResponse)
  /// AsyncBytes conforms to AsyncSequence for data delivery. The sequence is single pass. Delegate will not be called for response and data delivery.
  struct AsyncBytes : AsyncSequence {
    /// Underlying data task providing the bytes.
    var task: URLSessionDataTask { get }
    typealias Element = UInt8
    typealias AsyncIterator = URLSession.AsyncBytes.Iterator
    @frozen struct Iterator : AsyncIteratorProtocol {
      typealias Element = UInt8
      @usableFromInline
      var buffer: _AsyncBytesBuffer
      @inlinable @inline(__always) mutating func next() async throws -> UInt8?
    }
    __consuming func makeAsyncIterator() -> URLSession.AsyncBytes.Iterator
  }
  /// Returns a byte stream that conforms to AsyncSequence protocol.
  ///
  /// - Parameter request: The URLRequest for which to load data.
  /// - Parameter delegate: Task-specific delegate.
  /// - Returns: Data stream and response.
  func bytes(for request: URLRequest, delegate: URLSessionTaskDelegate? = nil) async throws -> (URLSession.AsyncBytes, URLResponse)
  /// Returns a byte stream that conforms to AsyncSequence protocol.
  ///
  /// - Parameter url: The URL for which to load data.
  /// - Parameter delegate: Task-specific delegate.
  /// - Returns: Data stream and response.
  func bytes(from url: URL, delegate: URLSessionTaskDelegate? = nil) async throws -> (URLSession.AsyncBytes, URLResponse)
}

@available(macOS 10.15, iOS 13.0, tvOS 13.0, watchOS 6.0, *)
extension URLSession {
  /// Returns a publisher that wraps a URL session data task for a given URL.
  ///
  /// The publisher publishes data when the task completes, or terminates if the task fails with an error.
  /// - Parameter url: The URL for which to create a data task.
  /// - Returns: A publisher that wraps a data task for the URL.
  func dataTaskPublisher(for url: URL) -> URLSession.DataTaskPublisher
  /// Returns a publisher that wraps a URL session data task for a given URL request.
  ///
  /// The publisher publishes data when the task completes, or terminates if the task fails with an error.
  /// - Parameter request: The URL request for which to create a data task.
  /// - Returns: A publisher that wraps a data task for the URL request.
  func dataTaskPublisher(for request: URLRequest) -> URLSession.DataTaskPublisher
  struct DataTaskPublisher : Publisher {
    typealias Output = (data: Data, response: URLResponse)
    typealias Failure = URLError
    let request: URLRequest
    let session: URLSession
    init(request: URLRequest, session: URLSession)
    func receive<S>(subscriber: S) where S : Subscriber, S.Failure == URLError, S.Input == (data: Data, response: URLResponse)
  }
}
extension URLSession {
  func dataTask(with request: URLRequest, completionHandler: @escaping (Data?, URLResponse?, Error?) -> Void) -> URLSessionDataTask
  @available(swift, obsoleted: 3, renamed: "dataTask(with:completionHandler:)")
  func dataTaskWithRequest(_ request: URLRequest, completionHandler: @escaping (Data?, URLResponse?, Error?) -> Void) -> URLSessionDataTask
  func dataTask(with url: URL, completionHandler: @escaping (Data?, URLResponse?, Error?) -> Void) -> URLSessionDataTask
  @available(swift, obsoleted: 3, renamed: "dataTask(with:completionHandler:)")
  func dataTaskWithURL(_ url: URL, completionHandler: @escaping (Data?, URLResponse?, Error?) -> Void) -> URLSessionDataTask
  func uploadTask(with request: URLRequest, fromFile fileURL: URL, completionHandler: @escaping (Data?, URLResponse?, Error?) -> Void) -> URLSessionUploadTask
  @available(swift, obsoleted: 3, renamed: "uploadTask(with:fromFile:completionHandler:)")
  func uploadTaskWithRequest(_ request: URLRequest, fromFile fileURL: URL, completionHandler: @escaping (Data?, URLResponse?, Error?) -> Void) -> URLSessionUploadTask
  func uploadTask(with request: URLRequest, from bodyData: Data?, completionHandler: @escaping (Data?, URLResponse?, Error?) -> Void) -> URLSessionUploadTask
  @available(swift, obsoleted: 3, renamed: "uploadTask(with:from:completionHandler:)")
  func uploadTaskWithRequest(_ request: URLRequest, fromData bodyData: Data?, completionHandler: @escaping (Data?, URLResponse?, Error?) -> Void) -> URLSessionUploadTask
  func downloadTask(with request: URLRequest, completionHandler: @escaping (URL?, URLResponse?, Error?) -> Void) -> URLSessionDownloadTask
  @available(swift, obsoleted: 3, renamed: "downloadTask(with:completionHandler:)")
  func downloadTaskWithRequest(_ request: URLRequest, completionHandler: @escaping (URL?, URLResponse?, Error?) -> Void) -> URLSessionDownloadTask
  func downloadTask(with url: URL, completionHandler: @escaping (URL?, URLResponse?, Error?) -> Void) -> URLSessionDownloadTask
  @available(swift, obsoleted: 3, renamed: "downloadTask(with:completionHandler:)")
  func downloadTaskWithURL(_ url: URL, completionHandler: @escaping (URL?, URLResponse?, Error?) -> Void) -> URLSessionDownloadTask
  func downloadTask(withResumeData resumeData: Data, completionHandler: @escaping (URL?, URLResponse?, Error?) -> Void) -> URLSessionDownloadTask
  @available(swift, obsoleted: 3, renamed: "downloadTask(withResumeData:completionHandler:)")
  func downloadTaskWithResumeData(_ resumeData: Data, completionHandler: @escaping (URL?, URLResponse?, Error?) -> Void) -> URLSessionDownloadTask
}
@available(iOS 7.0, *)
@available(swift, obsoleted: 3, renamed: "URLSessionTask.State")
typealias NSURLSessionTaskState = URLSessionTask.State
extension URLSessionTask {
  @available(iOS 7.0, *)
  enum State : Int, @unchecked Sendable {
    init?(rawValue: Int)
    var rawValue: Int { get }
    typealias RawValue = Int
    case running
    @available(swift, obsoleted: 3, renamed: "running")
    static var Running: URLSessionTask.State { get }
    case suspended
    @available(swift, obsoleted: 3, renamed: "suspended")
    static var Suspended: URLSessionTask.State { get }
    case canceling
    @available(swift, obsoleted: 3, renamed: "canceling")
    static var Canceling: URLSessionTask.State { get }
    case completed
    @available(swift, obsoleted: 3, renamed: "completed")
    static var Completed: URLSessionTask.State { get }
  }
  @available(iOS 8.0, *)
  class let defaultPriority: Float
  @available(iOS 8.0, *)
  class let lowPriority: Float
  @available(iOS 8.0, *)
  class let highPriority: Float
}
@available(iOS 7.0, *)
@available(swift, obsoleted: 3, renamed: "URLSessionTask")
typealias NSURLSessionTask = URLSessionTask
@available(iOS 7.0, *)
class URLSessionTask : NSObject, NSCopying, ProgressReporting {
  var taskIdentifier: Int { get }
  var originalRequest: URLRequest? { get }
  var currentRequest: URLRequest? { get }
  @NSCopying var response: URLResponse? { get }
  @available(iOS 15.0, *)
  var delegate: URLSessionTaskDelegate?
  @available(iOS 11.0, *)
  var progress: Progress { get }
  @available(iOS 11.0, *)
  var earliestBeginDate: Date?
  @available(iOS 11.0, *)
  var countOfBytesClientExpectsToSend: Int64
  @available(iOS 11.0, *)
  var countOfBytesClientExpectsToReceive: Int64
  var countOfBytesSent: Int64 { get }
  var countOfBytesReceived: Int64 { get }
  var countOfBytesExpectedToSend: Int64 { get }
  var countOfBytesExpectedToReceive: Int64 { get }
  var taskDescription: String?
  func cancel()
  var state: URLSessionTask.State { get }
  var error: Error? { get }
  func suspend()
  func resume()
  @available(iOS 8.0, *)
  var priority: Float
  @available(iOS 14.5, *)
  var prefersIncrementalDelivery: Bool
  @available(iOS, introduced: 7.0, deprecated: 13.0, message: "Not supported")
  init()
  @available(iOS, introduced: 7.0, deprecated: 13.0, message: "Not supported")
  class func new() -> Self
  @available(iOS 7.0, *)
  func copy(with zone: NSZone? = nil) -> Any
}
@available(iOS 8.0, *)
@available(swift, obsoleted: 3, renamed: "URLSessionTask.defaultPriority")
let NSURLSessionTaskPriorityDefault: Float
@available(iOS 8.0, *)
@available(swift, obsoleted: 3, renamed: "URLSessionTask.lowPriority")
let NSURLSessionTaskPriorityLow: Float
@available(iOS 8.0, *)
@available(swift, obsoleted: 3, renamed: "URLSessionTask.highPriority")
let NSURLSessionTaskPriorityHigh: Float
@available(iOS 7.0, *)
@available(swift, obsoleted: 3, renamed: "URLSessionDataTask")
typealias NSURLSessionDataTask = URLSessionDataTask
@available(iOS 7.0, *)
class URLSessionDataTask : URLSessionTask {
  @available(iOS, introduced: 7.0, deprecated: 13.0, message: "Please use -[NSURLSession dataTaskWithRequest:] or other NSURLSession methods to create instances")
  init()
  @available(iOS, introduced: 7.0, deprecated: 13.0, message: "Please use -[NSURLSession dataTaskWithRequest:] or other NSURLSession methods to create instances")
  class func new() -> Self
}
@available(iOS 7.0, *)
@available(swift, obsoleted: 3, renamed: "URLSessionUploadTask")
typealias NSURLSessionUploadTask = URLSessionUploadTask
@available(iOS 7.0, *)
class URLSessionUploadTask : URLSessionDataTask {
  @available(iOS, introduced: 7.0, deprecated: 13.0, message: "Please use -[NSURLSession uploadTaskWithStreamedRequest:] or other NSURLSession methods to create instances")
  init()
  @available(iOS, introduced: 7.0, deprecated: 13.0, message: "Please use -[NSURLSession uploadTaskWithStreamedRequest:] or other NSURLSession methods to create instances")
  class func new() -> Self
}
@available(iOS 7.0, *)
@available(swift, obsoleted: 3, renamed: "URLSessionDownloadTask")
typealias NSURLSessionDownloadTask = URLSessionDownloadTask
@available(iOS 7.0, *)
class URLSessionDownloadTask : URLSessionTask {
  func cancel(byProducingResumeData completionHandler: @escaping @Sendable (Data?) -> Void)
  func cancelByProducingResumeData() async -> Data?
  @available(swift, obsoleted: 3, renamed: "cancel(byProducingResumeData:)")
  func cancelByProducingResumeData(_ completionHandler: @escaping @Sendable (Data?) -> Void)
  @available(iOS, introduced: 7.0, deprecated: 13.0, message: "Please use -[NSURLSession downloadTaskWithRequest:] or other NSURLSession methods to create instances")
  init()
  @available(iOS, introduced: 7.0, deprecated: 13.0, message: "Please use -[NSURLSession downloadTaskWithRequest:] or other NSURLSession methods to create instances")
  class func new() -> Self
}
@available(iOS 9.0, *)
@available(swift, obsoleted: 3, renamed: "URLSessionStreamTask")
typealias NSURLSessionStreamTask = URLSessionStreamTask
@available(iOS 9.0, *)
class URLSessionStreamTask : URLSessionTask {
  func readData(ofMinLength minBytes: Int, maxLength maxBytes: Int, timeout: TimeInterval, completionHandler: @escaping @Sendable (Data?, Bool, Error?) -> Void)
  func readData(ofMinLength minBytes: Int, maxLength maxBytes: Int, timeout: TimeInterval) async throws -> (Data?, Bool)
  @available(swift, obsoleted: 3, renamed: "readData(ofMinLength:maxLength:timeout:completionHandler:)")
  func readDataOfMinLength(_ minBytes: Int, maxLength maxBytes: Int, timeout: TimeInterval, completionHandler: @escaping @Sendable (Data?, Bool, Error?) -> Void)
  func write(_ data: Data, timeout: TimeInterval, completionHandler: @escaping @Sendable (Error?) -> Void)
  func write(_ data: Data, timeout: TimeInterval) async throws
  @available(swift, obsoleted: 3, renamed: "write(_:timeout:completionHandler:)")
  func writeData(_ data: Data, timeout: TimeInterval, completionHandler: @escaping @Sendable (Error?) -> Void)
  func captureStreams()
  func closeWrite()
  func closeRead()
  func startSecureConnection()
  @available(iOS, introduced: 7.0, deprecated: 13.0, message: "TLS cannot be disabled once it is enabled")
  func stopSecureConnection()
  @available(iOS, introduced: 7.0, deprecated: 13.0, message: "Please use -[NSURLSession streamTaskWithHostName:port:] or other NSURLSession methods to create instances")
  init()
  @available(iOS, introduced: 7.0, deprecated: 13.0, message: "Please use -[NSURLSession streamTaskWithHostName:port:] or other NSURLSession methods to create instances")
  class func new() -> Self
}
@available(iOS 13.0, *)
enum __NSURLSessionWebSocketMessageType : Int, @unchecked Sendable {
  init?(rawValue: Int)
  var rawValue: Int { get }
  typealias RawValue = Int
  case data
  @available(swift, obsoleted: 3, renamed: "data")
  static var Data: __NSURLSessionWebSocketMessageType { get }
  case string
  @available(swift, obsoleted: 3, renamed: "string")
  static var String: __NSURLSessionWebSocketMessageType { get }
}
@available(iOS 13.0, *)
class __NSURLSessionWebSocketMessage : NSObject {
  init(data: Data)
  init(string: String)
  var type: __NSURLSessionWebSocketMessageType { get }
  var data: Data? { get }
  var string: String? { get }
  @available(*, unavailable)
  convenience init()
  @available(*, unavailable)
  class func new() -> Self
}
@available(iOS 13.0, *)
@available(swift, obsoleted: 3, renamed: "URLSessionWebSocketTask.CloseCode")
typealias NSURLSessionWebSocketCloseCode = URLSessionWebSocketTask.CloseCode
extension URLSessionWebSocketTask {
  @available(iOS 13.0, *)
  enum CloseCode : Int, @unchecked Sendable {
    init?(rawValue: Int)
    var rawValue: Int { get }
    typealias RawValue = Int
    case invalid
    @available(swift, obsoleted: 3, renamed: "invalid")
    static var Invalid: URLSessionWebSocketTask.CloseCode { get }
    case normalClosure
    @available(swift, obsoleted: 3, renamed: "normalClosure")
    static var NormalClosure: URLSessionWebSocketTask.CloseCode { get }
    case goingAway
    @available(swift, obsoleted: 3, renamed: "goingAway")
    static var GoingAway: URLSessionWebSocketTask.CloseCode { get }
    case protocolError
    @available(swift, obsoleted: 3, renamed: "protocolError")
    static var ProtocolError: URLSessionWebSocketTask.CloseCode { get }
    case unsupportedData
    @available(swift, obsoleted: 3, renamed: "unsupportedData")
    static var UnsupportedData: URLSessionWebSocketTask.CloseCode { get }
    case noStatusReceived
    @available(swift, obsoleted: 3, renamed: "noStatusReceived")
    static var NoStatusReceived: URLSessionWebSocketTask.CloseCode { get }
    case abnormalClosure
    @available(swift, obsoleted: 3, renamed: "abnormalClosure")
    static var AbnormalClosure: URLSessionWebSocketTask.CloseCode { get }
    case invalidFramePayloadData
    @available(swift, obsoleted: 3, renamed: "invalidFramePayloadData")
    static var InvalidFramePayloadData: URLSessionWebSocketTask.CloseCode { get }
    case policyViolation
    @available(swift, obsoleted: 3, renamed: "policyViolation")
    static var PolicyViolation: URLSessionWebSocketTask.CloseCode { get }
    case messageTooBig
    @available(swift, obsoleted: 3, renamed: "messageTooBig")
    static var MessageTooBig: URLSessionWebSocketTask.CloseCode { get }
    case mandatoryExtensionMissing
    @available(swift, obsoleted: 3, renamed: "mandatoryExtensionMissing")
    static var MandatoryExtensionMissing: URLSessionWebSocketTask.CloseCode { get }
    case internalServerError
    @available(swift, obsoleted: 3, renamed: "internalServerError")
    static var InternalServerError: URLSessionWebSocketTask.CloseCode { get }
    case tlsHandshakeFailure
    @available(swift, obsoleted: 3, renamed: "tlsHandshakeFailure")
    static var TLSHandshakeFailure: URLSessionWebSocketTask.CloseCode { get }
  }
}
@available(iOS 13.0, *)
@available(swift, obsoleted: 3, renamed: "URLSessionWebSocketTask")
typealias NSURLSessionWebSocketTask = URLSessionWebSocketTask
@available(iOS 13.0, *)
class URLSessionWebSocketTask : URLSessionTask {
  func __send(_ message: __NSURLSessionWebSocketMessage, completionHandler: @escaping @Sendable (Error?) -> Void)
  func __send(_ message: __NSURLSessionWebSocketMessage) async throws
  @available(swift, obsoleted: 3, renamed: "__send(_:completionHandler:)")
  func __sendMessage(_ message: __NSURLSessionWebSocketMessage, completionHandler: @escaping @Sendable (Error?) -> Void)
  func __receiveMessage(completionHandler: @escaping @Sendable (__NSURLSessionWebSocketMessage?, Error?) -> Void)
  func __receiveMessage() async throws -> __NSURLSessionWebSocketMessage
  @available(swift, obsoleted: 3, renamed: "__receiveMessage(completionHandler:)")
  func __receiveMessageWithCompletionHandler(_ completionHandler: @escaping @Sendable (__NSURLSessionWebSocketMessage?, Error?) -> Void)
  func sendPing(pongReceiveHandler: @escaping (Error?) -> Void)
  @available(swift, obsoleted: 3, renamed: "sendPing(pongReceiveHandler:)")
  func sendPingWithPongReceiveHandler(_ pongReceiveHandler: @escaping (Error?) -> Void)
  func cancel(with closeCode: URLSessionWebSocketTask.CloseCode, reason: Data?)
  @available(swift, obsoleted: 3, renamed: "cancel(with:reason:)")
  func cancelWithCloseCode(_ closeCode: URLSessionWebSocketTask.CloseCode, reason: Data?)
  var maximumMessageSize: Int
  var closeCode: URLSessionWebSocketTask.CloseCode { get }
  var closeReason: Data? { get }
  @available(*, unavailable)
  init()
  @available(*, unavailable)
  class func new() -> Self
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension URLSessionWebSocketTask {
  enum Message {
    case data(Data)
    case string(String)
  }
  func send(_ message: URLSessionWebSocketTask.Message, completionHandler: @escaping (Error?) -> Void)
  @_silgen_name("_$sSo25NSURLSessionWebSocketTaskC10FoundationE4sendyyAbCE7MessageOYaKF")
  @_alwaysEmitIntoClient func send(_ message: URLSessionWebSocketTask.Message) async throws
  func receive(completionHandler: @escaping (Result<URLSessionWebSocketTask.Message, Error>) -> Void)
  @_silgen_name("_$sSo25NSURLSessionWebSocketTaskC10FoundationE7receiveAbCE7MessageOyYaKF")
  @_alwaysEmitIntoClient func receive() async throws -> URLSessionWebSocketTask.Message
}

/**
 @enum NSURLSessionMultipathServiceType
 
 @discussion The NSURLSessionMultipathServiceType enum defines constants that
 can be used to specify the multipath service type to associate an NSURLSession.  The
 multipath service type determines whether multipath TCP should be attempted and the conditions
 for creating and switching between subflows.  Using these service types requires the appropriate entitlement.  Any connection attempt will fail if the process does not have the required entitlement.
 A primary interface is a generally less expensive interface in terms of both cost and power (such as WiFi or ethernet).  A secondary interface is more expensive (such as 3G or LTE).
 
 @constant NSURLSessionMultipathServiceTypeNone Specifies that multipath tcp should not be used.  Connections will use a single flow.
 This is the default value.  No entitlement is required to set this value.
 
 @constant NSURLSessionMultipathServiceTypeHandover Specifies that a secondary subflow should only be used
 when the primary subflow is not performing adequately.   Requires the com.apple.developer.networking.multipath entilement.
 
 @constant NSURLSessionMultipathServiceTypeInteractive Specifies that a secodary subflow should be used if the
 primary subflow is not performing adequately (packet loss, high round trip times, bandwidth issues).  The secondary
 subflow will be created more aggressively than with NSURLSessionMultipathServiceTypeHandover.  Requires the com.apple.developer.networking.multipath entitlement.
 
 @constant NSURLSessionMultipathServiceTypeAggregate Specifies that multiple subflows across multiple interfaces should be
 used for better bandwidth.  This mode is only available for experimentation on devices configured for development use.
 It can be enabled in the Developer section of the Settings app.
 
 */
@available(iOS 11.0, *)
@available(swift, obsoleted: 3, renamed: "URLSessionConfiguration.MultipathServiceType")
typealias NSURLSessionMultipathServiceType = URLSessionConfiguration.MultipathServiceType
extension URLSessionConfiguration {

  /**
   @enum NSURLSessionMultipathServiceType
   
   @discussion The NSURLSessionMultipathServiceType enum defines constants that
   can be used to specify the multipath service type to associate an NSURLSession.  The
   multipath service type determines whether multipath TCP should be attempted and the conditions
   for creating and switching between subflows.  Using these service types requires the appropriate entitlement.  Any connection attempt will fail if the process does not have the required entitlement.
   A primary interface is a generally less expensive interface in terms of both cost and power (such as WiFi or ethernet).  A secondary interface is more expensive (such as 3G or LTE).
   
   @constant NSURLSessionMultipathServiceTypeNone Specifies that multipath tcp should not be used.  Connections will use a single flow.
   This is the default value.  No entitlement is required to set this value.
   
   @constant NSURLSessionMultipathServiceTypeHandover Specifies that a secondary subflow should only be used
   when the primary subflow is not performing adequately.   Requires the com.apple.developer.networking.multipath entilement.
   
   @constant NSURLSessionMultipathServiceTypeInteractive Specifies that a secodary subflow should be used if the
   primary subflow is not performing adequately (packet loss, high round trip times, bandwidth issues).  The secondary
   subflow will be created more aggressively than with NSURLSessionMultipathServiceTypeHandover.  Requires the com.apple.developer.networking.multipath entitlement.
   
   @constant NSURLSessionMultipathServiceTypeAggregate Specifies that multiple subflows across multiple interfaces should be
   used for better bandwidth.  This mode is only available for experimentation on devices configured for development use.
   It can be enabled in the Developer section of the Settings app.
   
   */
  @available(iOS 11.0, *)
  enum MultipathServiceType : Int, @unchecked Sendable {
    init?(rawValue: Int)
    var rawValue: Int { get }
    typealias RawValue = Int
    case none
    @available(swift, obsoleted: 3, renamed: "none")
    static var None: URLSessionConfiguration.MultipathServiceType { get }
    case handover
    @available(swift, obsoleted: 3, renamed: "handover")
    static var Handover: URLSessionConfiguration.MultipathServiceType { get }
    case interactive
    @available(swift, obsoleted: 3, renamed: "interactive")
    static var Interactive: URLSessionConfiguration.MultipathServiceType { get }
    case aggregate
    @available(swift, obsoleted: 3, renamed: "aggregate")
    static var Aggregate: URLSessionConfiguration.MultipathServiceType { get }
  }
}
@available(iOS 7.0, *)
@available(swift, obsoleted: 3, renamed: "URLSessionConfiguration")
typealias NSURLSessionConfiguration = URLSessionConfiguration
@available(iOS 7.0, *)
class URLSessionConfiguration : NSObject, NSCopying {
  class var `default`: URLSessionConfiguration { get }
  @available(swift, obsoleted: 3, renamed: "default")
  class var defaultSessionConfiguration: URLSessionConfiguration { get }
  class var ephemeral: URLSessionConfiguration { get }
  @available(swift, obsoleted: 3, renamed: "ephemeral")
  class var ephemeralSessionConfiguration: URLSessionConfiguration { get }
  @available(iOS 8.0, *)
  class func background(withIdentifier identifier: String) -> URLSessionConfiguration
  @available(iOS 8.0, *)
  @available(swift, obsoleted: 3, renamed: "background(withIdentifier:)")
  class func backgroundSessionConfigurationWithIdentifier(_ identifier: String) -> URLSessionConfiguration
  var identifier: String? { get }
  var requestCachePolicy: NSURLRequest.CachePolicy
  var timeoutIntervalForRequest: TimeInterval
  var timeoutIntervalForResource: TimeInterval
  var networkServiceType: NSURLRequest.NetworkServiceType
  var allowsCellularAccess: Bool
  @available(iOS 13.0, *)
  var allowsExpensiveNetworkAccess: Bool
  @available(iOS 13.0, *)
  var allowsConstrainedNetworkAccess: Bool
  @available(iOS 11.0, *)
  var waitsForConnectivity: Bool
  @available(iOS 7.0, *)
  var isDiscretionary: Bool
  @available(iOS 7.0, *)
  @available(swift, obsoleted: 3, renamed: "isDiscretionary")
  var discretionary: Bool
  @available(iOS 8.0, *)
  var sharedContainerIdentifier: String?
  @available(iOS 7.0, *)
  var sessionSendsLaunchEvents: Bool
  var connectionProxyDictionary: [AnyHashable : Any]?
  @available(iOS, introduced: 7.0, deprecated: 100000)
  var tlsMinimumSupportedProtocol: SSLProtocol
  @available(swift, obsoleted: 3, renamed: "tlsMinimumSupportedProtocol")
  @available(iOS, introduced: 7.0, deprecated: 100000)
  var TLSMinimumSupportedProtocol: SSLProtocol
  @available(iOS, introduced: 7.0, deprecated: 100000)
  var tlsMaximumSupportedProtocol: SSLProtocol
  @available(swift, obsoleted: 3, renamed: "tlsMaximumSupportedProtocol")
  @available(iOS, introduced: 7.0, deprecated: 100000)
  var TLSMaximumSupportedProtocol: SSLProtocol
  @available(iOS 13.0, *)
  var tlsMinimumSupportedProtocolVersion: tls_protocol_version_t
  @available(iOS 13.0, *)
  @available(swift, obsoleted: 3, renamed: "tlsMinimumSupportedProtocolVersion")
  var TLSMinimumSupportedProtocolVersion: tls_protocol_version_t
  @available(iOS 13.0, *)
  var tlsMaximumSupportedProtocolVersion: tls_protocol_version_t
  @available(iOS 13.0, *)
  @available(swift, obsoleted: 3, renamed: "tlsMaximumSupportedProtocolVersion")
  var TLSMaximumSupportedProtocolVersion: tls_protocol_version_t
  var httpShouldUsePipelining: Bool
  @available(swift, obsoleted: 3, renamed: "httpShouldUsePipelining")
  var HTTPShouldUsePipelining: Bool
  var httpShouldSetCookies: Bool
  @available(swift, obsoleted: 3, renamed: "httpShouldSetCookies")
  var HTTPShouldSetCookies: Bool
  var httpCookieAcceptPolicy: HTTPCookie.AcceptPolicy
  @available(swift, obsoleted: 3, renamed: "httpCookieAcceptPolicy")
  var HTTPCookieAcceptPolicy: HTTPCookie.AcceptPolicy
  var httpAdditionalHeaders: [AnyHashable : Any]?
  @available(swift, obsoleted: 3, renamed: "httpAdditionalHeaders")
  var HTTPAdditionalHeaders: [AnyHashable : Any]?
  var httpMaximumConnectionsPerHost: Int
  @available(swift, obsoleted: 3, renamed: "httpMaximumConnectionsPerHost")
  var HTTPMaximumConnectionsPerHost: Int
  var httpCookieStorage: HTTPCookieStorage?
  @available(swift, obsoleted: 3, renamed: "httpCookieStorage")
  var HTTPCookieStorage: HTTPCookieStorage?
  var urlCredentialStorage: URLCredentialStorage?
  @available(swift, obsoleted: 3, renamed: "urlCredentialStorage")
  var URLCredentialStorage: URLCredentialStorage?
  var urlCache: URLCache?
  @available(swift, obsoleted: 3, renamed: "urlCache")
  var URLCache: URLCache?
  @available(iOS 9.0, *)
  var shouldUseExtendedBackgroundIdleMode: Bool
  var protocolClasses: [AnyClass]?
  @available(iOS 11.0, *)
  var multipathServiceType: URLSessionConfiguration.MultipathServiceType
  @available(iOS, introduced: 7.0, deprecated: 13.0, message: "Please use NSURLSessionConfiguration.defaultSessionConfiguration or other class methods to create instances")
  init()
  @available(iOS, introduced: 7.0, deprecated: 13.0, message: "Please use NSURLSessionConfiguration.defaultSessionConfiguration or other class methods to create instances")
  class func new() -> Self
  @available(iOS 7.0, *)
  func copy(with zone: NSZone? = nil) -> Any
}
@available(iOS 11.0, *)
@available(swift, obsoleted: 3, renamed: "URLSession.DelayedRequestDisposition")
typealias NSURLSessionDelayedRequestDisposition = URLSession.DelayedRequestDisposition
extension URLSession {
  @available(iOS 11.0, *)
  enum DelayedRequestDisposition : Int, @unchecked Sendable {
    init?(rawValue: Int)
    var rawValue: Int { get }
    typealias RawValue = Int
    case continueLoading
    @available(swift, obsoleted: 3, renamed: "continueLoading")
    static var ContinueLoading: URLSession.DelayedRequestDisposition { get }
    case useNewRequest
    @available(swift, obsoleted: 3, renamed: "useNewRequest")
    static var UseNewRequest: URLSession.DelayedRequestDisposition { get }
    case cancel
    @available(swift, obsoleted: 3, renamed: "cancel")
    static var Cancel: URLSession.DelayedRequestDisposition { get }
  }
  @available(iOS 7.0, *)
  enum AuthChallengeDisposition : Int, @unchecked Sendable {
    init?(rawValue: Int)
    var rawValue: Int { get }
    typealias RawValue = Int
    case useCredential
    @available(swift, obsoleted: 3, renamed: "useCredential")
    static var UseCredential: URLSession.AuthChallengeDisposition { get }
    case performDefaultHandling
    @available(swift, obsoleted: 3, renamed: "performDefaultHandling")
    static var PerformDefaultHandling: URLSession.AuthChallengeDisposition { get }
    case cancelAuthenticationChallenge
    @available(swift, obsoleted: 3, renamed: "cancelAuthenticationChallenge")
    static var CancelAuthenticationChallenge: URLSession.AuthChallengeDisposition { get }
    case rejectProtectionSpace
    @available(swift, obsoleted: 3, renamed: "rejectProtectionSpace")
    static var RejectProtectionSpace: URLSession.AuthChallengeDisposition { get }
  }
  @available(iOS 7.0, *)
  enum ResponseDisposition : Int, @unchecked Sendable {
    init?(rawValue: Int)
    var rawValue: Int { get }
    typealias RawValue = Int
    case cancel
    @available(swift, obsoleted: 3, renamed: "cancel")
    static var Cancel: URLSession.ResponseDisposition { get }
    case allow
    @available(swift, obsoleted: 3, renamed: "allow")
    static var Allow: URLSession.ResponseDisposition { get }
    case becomeDownload
    @available(swift, obsoleted: 3, renamed: "becomeDownload")
    static var BecomeDownload: URLSession.ResponseDisposition { get }
    @available(iOS 9.0, *)
    case becomeStream
    @available(iOS 9.0, *)
    @available(swift, obsoleted: 3, renamed: "becomeStream")
    static var BecomeStream: URLSession.ResponseDisposition { get }
  }
}
@available(iOS 7.0, *)
@available(swift, obsoleted: 3, renamed: "URLSession.AuthChallengeDisposition")
typealias NSURLSessionAuthChallengeDisposition = URLSession.AuthChallengeDisposition
@available(iOS 7.0, *)
@available(swift, obsoleted: 3, renamed: "URLSession.ResponseDisposition")
typealias NSURLSessionResponseDisposition = URLSession.ResponseDisposition
@available(iOS 7.0, *)
@available(swift, obsoleted: 3, renamed: "URLSessionDelegate")
typealias NSURLSessionDelegate = URLSessionDelegate
@available(iOS 7.0, *)
protocol URLSessionDelegate : NSObjectProtocol {
  optional func urlSession(_ session: URLSession, didBecomeInvalidWithError error: Error?)
  @available(swift, obsoleted: 3, renamed: "urlSession(_:didBecomeInvalidWithError:)")
  optional func URLSession(_ session: URLSession, didBecomeInvalidWithError error: Error?)
  optional func urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping @Sendable (URLSession.AuthChallengeDisposition, URLCredential?) -> Void)
  optional func urlSession(_ session: URLSession, didReceive challenge: URLAuthenticationChallenge) async -> (URLSession.AuthChallengeDisposition, URLCredential?)
  @available(swift, obsoleted: 3, renamed: "urlSession(_:didReceive:completionHandler:)")
  optional func URLSession(_ session: URLSession, didReceiveChallenge challenge: URLAuthenticationChallenge, completionHandler: @escaping @Sendable (URLSession.AuthChallengeDisposition, URLCredential?) -> Void)
  @available(iOS 7.0, *)
  optional func urlSessionDidFinishEvents(forBackgroundURLSession session: URLSession)
  @available(iOS 7.0, *)
  @available(swift, obsoleted: 3, renamed: "urlSessionDidFinishEvents(forBackgroundURLSession:)")
  optional func URLSessionDidFinishEventsForBackgroundURLSession(_ session: URLSession)
}
@available(iOS 7.0, *)
@available(swift, obsoleted: 3, renamed: "URLSessionTaskDelegate")
typealias NSURLSessionTaskDelegate = URLSessionTaskDelegate
@available(iOS 7.0, *)
protocol URLSessionTaskDelegate : URLSessionDelegate {
  @available(iOS 11.0, *)
  optional func urlSession(_ session: URLSession, task: URLSessionTask, willBeginDelayedRequest request: URLRequest, completionHandler: @escaping @Sendable (URLSession.DelayedRequestDisposition, URLRequest?) -> Void)
  @available(iOS 11.0, *)
  optional func urlSession(_ session: URLSession, task: URLSessionTask, willBeginDelayedRequest request: URLRequest) async -> (URLSession.DelayedRequestDisposition, URLRequest?)
  @available(iOS 11.0, *)
  @available(swift, obsoleted: 3, renamed: "urlSession(_:task:willBeginDelayedRequest:completionHandler:)")
  optional func URLSession(_ session: URLSession, task: URLSessionTask, willBeginDelayedRequest request: URLRequest, completionHandler: @escaping @Sendable (URLSession.DelayedRequestDisposition, URLRequest?) -> Void)
  @available(iOS 11.0, *)
  optional func urlSession(_ session: URLSession, taskIsWaitingForConnectivity task: URLSessionTask)
  @available(iOS 11.0, *)
  @available(swift, obsoleted: 3, renamed: "urlSession(_:taskIsWaitingForConnectivity:)")
  optional func URLSession(_ session: URLSession, taskIsWaitingForConnectivity task: URLSessionTask)
  optional func urlSession(_ session: URLSession, task: URLSessionTask, willPerformHTTPRedirection response: HTTPURLResponse, newRequest request: URLRequest, completionHandler: @escaping @Sendable (URLRequest?) -> Void)
  optional func urlSession(_ session: URLSession, task: URLSessionTask, willPerformHTTPRedirection response: HTTPURLResponse, newRequest request: URLRequest) async -> URLRequest?
  @available(swift, obsoleted: 3, renamed: "urlSession(_:task:willPerformHTTPRedirection:newRequest:completionHandler:)")
  optional func URLSession(_ session: URLSession, task: URLSessionTask, willPerformHTTPRedirection response: HTTPURLResponse, newRequest request: URLRequest, completionHandler: @escaping @Sendable (URLRequest?) -> Void)
  optional func urlSession(_ session: URLSession, task: URLSessionTask, didReceive challenge: URLAuthenticationChallenge, completionHandler: @escaping @Sendable (URLSession.AuthChallengeDisposition, URLCredential?) -> Void)
  optional func urlSession(_ session: URLSession, task: URLSessionTask, didReceive challenge: URLAuthenticationChallenge) async -> (URLSession.AuthChallengeDisposition, URLCredential?)
  @available(swift, obsoleted: 3, renamed: "urlSession(_:task:didReceive:completionHandler:)")
  optional func URLSession(_ session: URLSession, task: URLSessionTask, didReceiveChallenge challenge: URLAuthenticationChallenge, completionHandler: @escaping @Sendable (URLSession.AuthChallengeDisposition, URLCredential?) -> Void)
  optional func urlSession(_ session: URLSession, task: URLSessionTask, needNewBodyStream completionHandler: @escaping @Sendable (InputStream?) -> Void)
  optional func urlSession(_ session: URLSession, needNewBodyStreamForTask task: URLSessionTask) async -> InputStream?
  @available(swift, obsoleted: 3, renamed: "urlSession(_:task:needNewBodyStream:)")
  optional func URLSession(_ session: URLSession, task: URLSessionTask, needNewBodyStream completionHandler: @escaping @Sendable (InputStream?) -> Void)
  optional func urlSession(_ session: URLSession, task: URLSessionTask, didSendBodyData bytesSent: Int64, totalBytesSent: Int64, totalBytesExpectedToSend: Int64)
  @available(swift, obsoleted: 3, renamed: "urlSession(_:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:)")
  optional func URLSession(_ session: URLSession, task: URLSessionTask, didSendBodyData bytesSent: Int64, totalBytesSent: Int64, totalBytesExpectedToSend: Int64)
  @available(iOS 10.0, *)
  optional func urlSession(_ session: URLSession, task: URLSessionTask, didFinishCollecting metrics: URLSessionTaskMetrics)
  @available(iOS 10.0, *)
  @available(swift, obsoleted: 3, renamed: "urlSession(_:task:didFinishCollecting:)")
  optional func URLSession(_ session: URLSession, task: URLSessionTask, didFinishCollectingMetrics metrics: URLSessionTaskMetrics)
  optional func urlSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?)
  @available(swift, obsoleted: 3, renamed: "urlSession(_:task:didCompleteWithError:)")
  optional func URLSession(_ session: URLSession, task: URLSessionTask, didCompleteWithError error: Error?)
}
@available(iOS 7.0, *)
@available(swift, obsoleted: 3, renamed: "URLSessionDataDelegate")
typealias NSURLSessionDataDelegate = URLSessionDataDelegate
@available(iOS 7.0, *)
protocol URLSessionDataDelegate : URLSessionTaskDelegate {
  optional func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive response: URLResponse, completionHandler: @escaping @Sendable (URLSession.ResponseDisposition) -> Void)
  optional func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive response: URLResponse) async -> URLSession.ResponseDisposition
  @available(swift, obsoleted: 3, renamed: "urlSession(_:dataTask:didReceive:completionHandler:)")
  optional func URLSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceiveResponse response: URLResponse, completionHandler: @escaping @Sendable (URLSession.ResponseDisposition) -> Void)
  optional func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didBecome downloadTask: URLSessionDownloadTask)
  @available(swift, obsoleted: 3, renamed: "urlSession(_:dataTask:didBecome:)")
  optional func URLSession(_ session: URLSession, dataTask: URLSessionDataTask, didBecomeDownloadTask downloadTask: URLSessionDownloadTask)
  @available(iOS 9.0, *)
  optional func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didBecome streamTask: URLSessionStreamTask)
  @available(iOS 9.0, *)
  @available(swift, obsoleted: 3, renamed: "urlSession(_:dataTask:didBecome:)")
  optional func URLSession(_ session: URLSession, dataTask: URLSessionDataTask, didBecomeStreamTask streamTask: URLSessionStreamTask)
  optional func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data)
  @available(swift, obsoleted: 3, renamed: "urlSession(_:dataTask:didReceive:)")
  optional func URLSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceiveData data: Data)
  optional func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, willCacheResponse proposedResponse: CachedURLResponse, completionHandler: @escaping @Sendable (CachedURLResponse?) -> Void)
  optional func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, willCacheResponse proposedResponse: CachedURLResponse) async -> CachedURLResponse?
  @available(swift, obsoleted: 3, renamed: "urlSession(_:dataTask:willCacheResponse:completionHandler:)")
  optional func URLSession(_ session: URLSession, dataTask: URLSessionDataTask, willCacheResponse proposedResponse: CachedURLResponse, completionHandler: @escaping @Sendable (CachedURLResponse?) -> Void)
}
@available(iOS 7.0, *)
@available(swift, obsoleted: 3, renamed: "URLSessionDownloadDelegate")
typealias NSURLSessionDownloadDelegate = URLSessionDownloadDelegate
@available(iOS 7.0, *)
protocol URLSessionDownloadDelegate : URLSessionTaskDelegate {
  func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingTo location: URL)
  @available(swift, obsoleted: 3, renamed: "urlSession(_:downloadTask:didFinishDownloadingTo:)")
  func URLSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didFinishDownloadingToURL location: URL)
  optional func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didWriteData bytesWritten: Int64, totalBytesWritten: Int64, totalBytesExpectedToWrite: Int64)
  @available(swift, obsoleted: 3, renamed: "urlSession(_:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:)")
  optional func URLSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didWriteData bytesWritten: Int64, totalBytesWritten: Int64, totalBytesExpectedToWrite: Int64)
  optional func urlSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didResumeAtOffset fileOffset: Int64, expectedTotalBytes: Int64)
  @available(swift, obsoleted: 3, renamed: "urlSession(_:downloadTask:didResumeAtOffset:expectedTotalBytes:)")
  optional func URLSession(_ session: URLSession, downloadTask: URLSessionDownloadTask, didResumeAtOffset fileOffset: Int64, expectedTotalBytes: Int64)
}
@available(iOS 9.0, *)
@available(swift, obsoleted: 3, renamed: "URLSessionStreamDelegate")
typealias NSURLSessionStreamDelegate = URLSessionStreamDelegate
@available(iOS 9.0, *)
protocol URLSessionStreamDelegate : URLSessionTaskDelegate {
  optional func urlSession(_ session: URLSession, readClosedFor streamTask: URLSessionStreamTask)
  @available(swift, obsoleted: 3, renamed: "urlSession(_:readClosedFor:)")
  optional func URLSession(_ session: URLSession, readClosedForStreamTask streamTask: URLSessionStreamTask)
  optional func urlSession(_ session: URLSession, writeClosedFor streamTask: URLSessionStreamTask)
  @available(swift, obsoleted: 3, renamed: "urlSession(_:writeClosedFor:)")
  optional func URLSession(_ session: URLSession, writeClosedForStreamTask streamTask: URLSessionStreamTask)
  optional func urlSession(_ session: URLSession, betterRouteDiscoveredFor streamTask: URLSessionStreamTask)
  @available(swift, obsoleted: 3, renamed: "urlSession(_:betterRouteDiscoveredFor:)")
  optional func URLSession(_ session: URLSession, betterRouteDiscoveredForStreamTask streamTask: URLSessionStreamTask)
  optional func urlSession(_ session: URLSession, streamTask: URLSessionStreamTask, didBecome inputStream: InputStream, outputStream: OutputStream)
  @available(swift, obsoleted: 3, renamed: "urlSession(_:streamTask:didBecome:outputStream:)")
  optional func URLSession(_ session: URLSession, streamTask: URLSessionStreamTask, didBecomeInputStream inputStream: InputStream, outputStream: OutputStream)
}
@available(iOS 13.0, *)
@available(swift, obsoleted: 3, renamed: "URLSessionWebSocketDelegate")
typealias NSURLSessionWebSocketDelegate = URLSessionWebSocketDelegate
@available(iOS 13.0, *)
protocol URLSessionWebSocketDelegate : URLSessionTaskDelegate {
  optional func urlSession(_ session: URLSession, webSocketTask: URLSessionWebSocketTask, didOpenWithProtocol protocol: String?)
  @available(swift, obsoleted: 3, renamed: "urlSession(_:webSocketTask:didOpenWithProtocol:)")
  optional func URLSession(_ session: URLSession, webSocketTask: URLSessionWebSocketTask, didOpenWithProtocol protocol: String?)
  optional func urlSession(_ session: URLSession, webSocketTask: URLSessionWebSocketTask, didCloseWith closeCode: URLSessionWebSocketTask.CloseCode, reason: Data?)
  @available(swift, obsoleted: 3, renamed: "urlSession(_:webSocketTask:didCloseWith:reason:)")
  optional func URLSession(_ session: URLSession, webSocketTask: URLSessionWebSocketTask, didCloseWithCode closeCode: URLSessionWebSocketTask.CloseCode, reason: Data?)
}
@available(iOS 7.0, *)
let NSURLSessionDownloadTaskResumeData: String
extension URLSessionConfiguration {
  @available(iOS, introduced: 7.0, deprecated: 8.0)
  class func backgroundSessionConfiguration(_ identifier: String) -> URLSessionConfiguration
}
@available(iOS 10.0, *)
@available(swift, obsoleted: 3, renamed: "URLSessionTaskMetrics.ResourceFetchType")
typealias NSURLSessionTaskMetricsResourceFetchType = URLSessionTaskMetrics.ResourceFetchType
extension URLSessionTaskMetrics {
  @available(iOS 10.0, *)
  enum ResourceFetchType : Int, @unchecked Sendable {
    init?(rawValue: Int)
    var rawValue: Int { get }
    typealias RawValue = Int
    case unknown
    @available(swift, obsoleted: 3, renamed: "unknown")
    static var Unknown: URLSessionTaskMetrics.ResourceFetchType { get }
    case networkLoad
    @available(swift, obsoleted: 3, renamed: "networkLoad")
    static var NetworkLoad: URLSessionTaskMetrics.ResourceFetchType { get }
    case serverPush
    @available(swift, obsoleted: 3, renamed: "serverPush")
    static var ServerPush: URLSessionTaskMetrics.ResourceFetchType { get }
    case localCache
    @available(swift, obsoleted: 3, renamed: "localCache")
    static var LocalCache: URLSessionTaskMetrics.ResourceFetchType { get }
  }
  @available(iOS 14.0, *)
  enum DomainResolutionProtocol : Int, @unchecked Sendable {
    init?(rawValue: Int)
    var rawValue: Int { get }
    typealias RawValue = Int
    case unknown
    @available(swift, obsoleted: 3, renamed: "unknown")
    static var Unknown: URLSessionTaskMetrics.DomainResolutionProtocol { get }
    case udp
    @available(swift, obsoleted: 3, renamed: "udp")
    static var UDP: URLSessionTaskMetrics.DomainResolutionProtocol { get }
    case tcp
    @available(swift, obsoleted: 3, renamed: "tcp")
    static var TCP: URLSessionTaskMetrics.DomainResolutionProtocol { get }
    case tls
    @available(swift, obsoleted: 3, renamed: "tls")
    static var TLS: URLSessionTaskMetrics.DomainResolutionProtocol { get }
    case https
    @available(swift, obsoleted: 3, renamed: "https")
    static var HTTPS: URLSessionTaskMetrics.DomainResolutionProtocol { get }
  }
}
@available(iOS 14.0, *)
@available(swift, obsoleted: 3, renamed: "URLSessionTaskMetrics.DomainResolutionProtocol")
typealias NSURLSessionTaskMetricsDomainResolutionProtocol = URLSessionTaskMetrics.DomainResolutionProtocol
@available(iOS 10.0, *)
@available(swift, obsoleted: 3, renamed: "URLSessionTaskTransactionMetrics")
typealias NSURLSessionTaskTransactionMetrics = URLSessionTaskTransactionMetrics
@available(iOS 10.0, *)
class URLSessionTaskTransactionMetrics : NSObject {
  var request: URLRequest { get }
  @NSCopying var response: URLResponse? { get }
  var fetchStartDate: Date? { get }
  var domainLookupStartDate: Date? { get }
  var domainLookupEndDate: Date? { get }
  var connectStartDate: Date? { get }
  var secureConnectionStartDate: Date? { get }
  var secureConnectionEndDate: Date? { get }
  var connectEndDate: Date? { get }
  var requestStartDate: Date? { get }
  var requestEndDate: Date? { get }
  var responseStartDate: Date? { get }
  var responseEndDate: Date? { get }
  var networkProtocolName: String? { get }
  var isProxyConnection: Bool { get }
  @available(swift, obsoleted: 3, renamed: "isProxyConnection")
  var proxyConnection: Bool { get }
  var isReusedConnection: Bool { get }
  @available(swift, obsoleted: 3, renamed: "isReusedConnection")
  var reusedConnection: Bool { get }
  var resourceFetchType: URLSessionTaskMetrics.ResourceFetchType { get }
  @available(iOS 13.0, *)
  var countOfRequestHeaderBytesSent: Int64 { get }
  @available(iOS 13.0, *)
  var countOfRequestBodyBytesSent: Int64 { get }
  @available(iOS 13.0, *)
  var countOfRequestBodyBytesBeforeEncoding: Int64 { get }
  @available(iOS 13.0, *)
  var countOfResponseHeaderBytesReceived: Int64 { get }
  @available(iOS 13.0, *)
  var countOfResponseBodyBytesReceived: Int64 { get }
  @available(iOS 13.0, *)
  var countOfResponseBodyBytesAfterDecoding: Int64 { get }
  @available(iOS 13.0, *)
  var localAddress: String? { get }
  @available(iOS 13.0, *)
  @NSCopying var __localPort: NSNumber? { get }
  @available(iOS 13.0, *)
  var remoteAddress: String? { get }
  @available(iOS 13.0, *)
  @NSCopying var __remotePort: NSNumber? { get }
  @available(iOS 13.0, *)
  @NSCopying var __negotiatedTLSProtocolVersion: NSNumber? { get }
  @available(iOS 13.0, *)
  @NSCopying var __negotiatedTLSCipherSuite: NSNumber? { get }
  @available(iOS 13.0, *)
  var isCellular: Bool { get }
  @available(iOS 13.0, *)
  @available(swift, obsoleted: 3, renamed: "isCellular")
  var cellular: Bool { get }
  @available(iOS 13.0, *)
  var isExpensive: Bool { get }
  @available(iOS 13.0, *)
  @available(swift, obsoleted: 3, renamed: "isExpensive")
  var expensive: Bool { get }
  @available(iOS 13.0, *)
  var isConstrained: Bool { get }
  @available(iOS 13.0, *)
  @available(swift, obsoleted: 3, renamed: "isConstrained")
  var constrained: Bool { get }
  @available(iOS 13.0, *)
  var isMultipath: Bool { get }
  @available(iOS 13.0, *)
  @available(swift, obsoleted: 3, renamed: "isMultipath")
  var multipath: Bool { get }
  @available(iOS 14.0, *)
  var domainResolutionProtocol: URLSessionTaskMetrics.DomainResolutionProtocol { get }
  @available(iOS, introduced: 10.0, deprecated: 13.0, message: "Not supported")
  init()
  @available(iOS, introduced: 10.0, deprecated: 13.0, message: "Not supported")
  class func new() -> Self
}

@available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
extension URLSessionTaskTransactionMetrics {
  var localPort: Int? { get }
  var remotePort: Int? { get }
  var negotiatedTLSProtocolVersion: tls_protocol_version_t? { get }
  var negotiatedTLSCipherSuite: tls_ciphersuite_t? { get }
}
@available(iOS 10.0, *)
@available(swift, obsoleted: 3, renamed: "URLSessionTaskMetrics")
typealias NSURLSessionTaskMetrics = URLSessionTaskMetrics
@available(iOS 10.0, *)
class URLSessionTaskMetrics : NSObject {
  var transactionMetrics: [URLSessionTaskTransactionMetrics] { get }
  var taskInterval: DateInterval { get }
  var redirectCount: Int { get }
  @available(iOS, introduced: 10.0, deprecated: 13.0, message: "Not supported")
  init()
  @available(iOS, introduced: 10.0, deprecated: 13.0, message: "Not supported")
  class func new() -> Self
}
