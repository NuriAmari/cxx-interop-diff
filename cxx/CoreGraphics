@_exported import CoreGraphics.CGAffineTransform
@_exported import CoreGraphics.CGBase
@_exported import CoreGraphics.CGBitmapContext
@_exported import CoreGraphics.CGColor
@_exported import CoreGraphics.CGColorConversionInfo
@_exported import CoreGraphics.CGColorSpace
@_exported import CoreGraphics.CGContext
@_exported import CoreGraphics.CGConvertColorDataWithFormat
@_exported import CoreGraphics.CGDataConsumer
@_exported import CoreGraphics.CGDataProvider
@_exported import CoreGraphics.CGError
@_exported import CoreGraphics.CGFont
@_exported import CoreGraphics.CGFunction
@_exported import CoreGraphics.CGGeometry
@_exported import CoreGraphics.CGGradient
@_exported import CoreGraphics.CGImage
@_exported import CoreGraphics.CGLayer
@_exported import CoreGraphics.CGPDFArray
@_exported import CoreGraphics.CGPDFContentStream
@_exported import CoreGraphics.CGPDFContext
@_exported import CoreGraphics.CGPDFDictionary
@_exported import CoreGraphics.CGPDFDocument
@_exported import CoreGraphics.CGPDFObject
@_exported import CoreGraphics.CGPDFOperatorTable
@_exported import CoreGraphics.CGPDFPage
@_exported import CoreGraphics.CGPDFScanner
@_exported import CoreGraphics.CGPDFStream
@_exported import CoreGraphics.CGPDFString
@_exported import CoreGraphics.CGPath
@_exported import CoreGraphics.CGPattern
@_exported import CoreGraphics.CGShading
import Darwin
import _Concurrency

@available(*, unavailable, message: "Use truncatingRemainder instead")
@_transparent func % (lhs: CGFloat, rhs: CGFloat) -> CGFloat

@available(*, unavailable, message: "Use formTruncatingRemainder instead")
@_transparent func %= (lhs: inout CGFloat, rhs: CGFloat)

@available(*, unavailable, message: "Use == instead")
func CGAffineTransformEqualToTransform(_ t1: CGAffineTransform, _ t2: CGAffineTransform) -> Bool

@available(*, unavailable, message: "Use == instead")
func CGColorEqualToColor(_ color1: CGColor?, _ color2: CGColor?) -> Bool

@available(*, unavailable, renamed: "getter:CGColor.components(self:)")
func CGColorGetComponents(_ color: CGColor?) -> UnsafePointer<CGFloat>

@available(*, unavailable, message: "Use class var white/black/clear instead")
func CGColorGetConstantColor(_ colorName: CFString?) -> CGColor?

@available(*, unavailable, renamed: "CGColorSpace.colorTable(self:_:)")
func CGColorSpaceGetColorTable(_ space: CGColorSpace?, _ table: UnsafeMutablePointer<UInt8>)

@available(*, unavailable, message: "Use colorTable.count instead")
func CGColorSpaceGetColorTableCount(_ space: CGColorSpace?) -> Int

@available(*, unavailable, message: "Use addArc(center:radius:startAngle:endAngle:clockwise:)")
func CGContextAddArc(_ c: CGContext?, _ x: CGFloat, _ y: CGFloat, _ radius: CGFloat, _ startAngle: CGFloat, _ endAngle: CGFloat, _ clockwise: Int32)

@available(*, unavailable, message: "Use addArc(self:x1:y1:x2:y2:radius:)")
func CGContextAddArcToPoint(_ c: CGContext?, _ x1: CGFloat, _ y1: CGFloat, _ x2: CGFloat, _ y2: CGFloat, _ radius: CGFloat)

@available(*, unavailable, message: "Use addCurve(to:control1:control2:) instead")
func CGContextAddCurveToPoint(_ c: CGContext?, _ cp1x: CGFloat, _ cp1y: CGFloat, _ cp2x: CGFloat, _ cp2y: CGFloat, _ x: CGFloat, _ y: CGFloat)

@available(*, unavailable, message: "Use addLine(to:) instead")
func CGContextAddLineToPoint(_ c: CGContext?, _ x: CGFloat, _ y: CGFloat)

@available(*, unavailable, message: "Use addLines(between:)")
func CGContextAddLines(_ c: CGContext?, _ points: UnsafePointer<CGPoint>, _ count: Int)

@available(*, unavailable, message: "Use addQuadCurve(to:control:)")
func CGContextAddQuadCurveToPoint(_ c: CGContext?, _ cpx: CGFloat, _ cpy: CGFloat, _ x: CGFloat, _ y: CGFloat)

@available(*, unavailable, message: "Use addRects(_:)")
func CGContextAddRects(_ c: CGContext?, _ rects: UnsafePointer<CGRect>, _ count: Int)

@available(*, unavailable, renamed: "CGContext.clip(self:)")
func CGContextClip(_ c: CGContext?)

@available(*, unavailable, message: "Use clip(to:)")
func CGContextClipToRects(_ c: CGContext?, _ rects: UnsafePointer<CGRect>, _ count: Int)

@available(*, unavailable, message: "Use draw(_:in:)")
func CGContextDrawImage(_ c: CGContext?, _ rect: CGRect, _ image: CGImage?)

@available(*, unavailable, message: "Use draw(_:at:)")
func CGContextDrawLayerAtPoint(_ context: CGContext?, _ point: CGPoint, _ layer: CGLayer?)

@available(*, unavailable, message: "Use draw(_:in:)")
func CGContextDrawLayerInRect(_ context: CGContext?, _ rect: CGRect, _ layer: CGLayer?)

@available(*, unavailable, message: "Use draw(_:in:byTiling:)")
func CGContextDrawTiledImage(_ c: CGContext?, _ rect: CGRect, _ image: CGImage?)

@available(*, unavailable, message: "Use clip(using:)")
func CGContextEOClip(_ c: CGContext?)

@available(*, unavailable, message: "Use fillPath(using:)")
func CGContextEOFillPath(_ c: CGContext?)

@available(*, unavailable, renamed: "CGContext.fillPath(self:)")
func CGContextFillPath(_ c: CGContext?)

@available(*, unavailable, message: "Use fill(self:_:count:)")
func CGContextFillRects(_ c: CGContext?, _ rects: UnsafePointer<CGRect>, _ count: Int)

@available(*, unavailable, renamed: "getter:CGContext.textPosition(self:)")
func CGContextGetTextPosition(_ c: CGContext?) -> CGPoint

@available(*, unavailable, message: "Use move(to:) instead")
func CGContextMoveToPoint(_ c: CGContext?, _ x: CGFloat, _ y: CGFloat)

@available(*, unavailable, message: "Use setLineDash(self:phase:lengths:)")
func CGContextSetLineDash(_ c: CGContext?, _ phase: CGFloat, _ lengths: UnsafePointer<CGFloat>, _ count: Int)

@available(*, unavailable, message: "Use var textPosition")
func CGContextSetTextPosition(_ c: CGContext?, _ x: CGFloat, _ y: CGFloat)

@available(*, unavailable, message: "Use showGlyphs(_:at:)")
func CGContextShowGlyphsAtPositions(_ c: CGContext?, _ glyphs: UnsafePointer<CGGlyph>, _ Lpositions: UnsafePointer<CGPoint>, _ count: Int)

@available(*, unavailable, message: "Use strokeLineSegments(self:between:count:)")
func CGContextStrokeLineSegments(_ c: CGContext?, _ points: UnsafePointer<CGPoint>, _ count: Int)

@available(*, unavailable, renamed: "CGFloat.greatestFiniteMagnitude")
var CGFLOAT_MAX: CGFloat { get }

@available(*, unavailable, renamed: "CGFloat.leastNormalMagnitude")
var CGFLOAT_MIN: CGFloat { get }

@frozen struct CGFloat {
  /// The native type used to store the CGFloat, which is Float on
  /// 32-bit architectures and Double on 64-bit architectures.
  typealias NativeType = Double
  @_transparent init()
  @_transparent init(_ value: Float)
  @_transparent init(_ value: Double)
  @_transparent init(_ value: CGFloat)
  /// The native value.
  var native: CGFloat.NativeType
}

extension CGFloat : SignedNumeric {
  @_alwaysEmitIntoClient init<T>(_ source: T) where T : BinaryInteger
  @_transparent init?<T>(exactly source: T) where T : BinaryInteger
  @_transparent var magnitude: CGFloat { get }
  typealias IntegerLiteralType = Int
  typealias Magnitude = CGFloat
}

extension CGFloat : BinaryFloatingPoint {
  typealias RawSignificand = UInt
  typealias Exponent = Int
  @_transparent static var exponentBitCount: Int { get }
  @_transparent static var significandBitCount: Int { get }
  @_transparent var bitPattern: UInt { get }
  @_transparent init(bitPattern: UInt)
  @_transparent var sign: FloatingPointSign { get }
  @_transparent var exponentBitPattern: UInt { get }
  @_transparent var significandBitPattern: UInt { get }
  @_transparent init(sign: FloatingPointSign, exponentBitPattern: UInt, significandBitPattern: UInt)
  @_transparent init(nan payload: CGFloat.RawSignificand, signaling: Bool)
  @_transparent static var infinity: CGFloat { get }
  @_transparent static var nan: CGFloat { get }
  @_transparent static var signalingNaN: CGFloat { get }
  @available(*, unavailable, renamed: "nan")
  static var quietNaN: CGFloat { get }
  @_transparent static var greatestFiniteMagnitude: CGFloat { get }
  @_transparent static var pi: CGFloat { get }
  @_transparent var ulp: CGFloat { get }
  @_transparent static var leastNormalMagnitude: CGFloat { get }
  @_transparent static var leastNonzeroMagnitude: CGFloat { get }
  @_transparent var exponent: Int { get }
  @_transparent var significand: CGFloat { get }
  @_transparent init(sign: FloatingPointSign, exponent: Int, significand: CGFloat)
  @_transparent mutating func round(_ rule: FloatingPointRoundingRule)
  @_transparent var nextUp: CGFloat { get }
  @_transparent mutating func negate()
  @_transparent static func += (lhs: inout CGFloat, rhs: CGFloat)
  @_transparent static func -= (lhs: inout CGFloat, rhs: CGFloat)
  @_transparent static func *= (lhs: inout CGFloat, rhs: CGFloat)
  @_transparent static func /= (lhs: inout CGFloat, rhs: CGFloat)
  @_transparent mutating func formTruncatingRemainder(dividingBy other: CGFloat)
  @_transparent mutating func formRemainder(dividingBy other: CGFloat)
  @_transparent mutating func formSquareRoot()
  @_transparent mutating func addProduct(_ lhs: CGFloat, _ rhs: CGFloat)
  @_transparent func isEqual(to other: CGFloat) -> Bool
  @_transparent func isLess(than other: CGFloat) -> Bool
  @_transparent func isLessThanOrEqualTo(_ other: CGFloat) -> Bool
  @_transparent var isNormal: Bool { get }
  @_transparent var isFinite: Bool { get }
  @_transparent var isZero: Bool { get }
  @_transparent var isSubnormal: Bool { get }
  @_transparent var isInfinite: Bool { get }
  @_transparent var isNaN: Bool { get }
  @_transparent var isSignalingNaN: Bool { get }
  @available(*, unavailable, renamed: "isSignalingNaN")
  var isSignaling: Bool { get }
  @_transparent var isCanonical: Bool { get }
  @_transparent var floatingPointClass: FloatingPointClassification { get }
  @_transparent var binade: CGFloat { get }
  @_transparent var significandWidth: Int { get }
  /// Create an instance initialized to `value`.
  @_transparent init(floatLiteral value: CGFloat.NativeType)
  /// Create an instance initialized to `value`.
  @_transparent init(integerLiteral value: Int)
  typealias FloatLiteralType = CGFloat.NativeType
  typealias RawExponent = UInt
}

extension CGFloat {
  @available(*, unavailable, renamed: "leastNormalMagnitude")
  static var min: CGFloat { get }
  @available(*, unavailable, renamed: "greatestFiniteMagnitude")
  static var max: CGFloat { get }
}

extension CGFloat : CustomReflectable {
  /// Returns a mirror that reflects `self`.
  var customMirror: Mirror { get }
}

extension CGFloat : CustomStringConvertible {
  /// A textual representation of `self`.
  @_transparent var description: String { get }
}

extension CGFloat : Hashable {
  /// The hash value.
  ///
  /// **Axiom:** `x == y` implies `x.hashValue == y.hashValue`
  ///
  /// - Note: the hash value is not guaranteed to be stable across
  ///   different invocations of the same program.  Do not persist the
  ///   hash value across program runs.
  @_transparent var hashValue: Int { get }
  /// Hashes the essential components of this value by feeding them into the
  /// given hasher.
  ///
  /// - Parameter hasher: The hasher to use when combining the components
  ///   of this instance.
  @inlinable @_transparent func hash(into hasher: inout Hasher)
  @_alwaysEmitIntoClient @inlinable func _rawHashValue(seed: Int) -> Int
}

extension CGFloat {
  @_transparent static func + (lhs: CGFloat, rhs: CGFloat) -> CGFloat
  @_transparent static func - (lhs: CGFloat, rhs: CGFloat) -> CGFloat
  @_transparent static func * (lhs: CGFloat, rhs: CGFloat) -> CGFloat
  @_transparent static func / (lhs: CGFloat, rhs: CGFloat) -> CGFloat
}

extension CGFloat : Strideable {
  /// Returns a stride `x` such that `self.advanced(by: x)` approximates
  /// `other`.
  ///
  /// - Complexity: O(1).
  @_transparent func distance(to other: CGFloat) -> CGFloat
  /// Returns a `Self` `x` such that `self.distance(to: x)` approximates
  /// `n`.
  ///
  /// - Complexity: O(1).
  @_transparent func advanced(by amount: CGFloat) -> CGFloat
  typealias Stride = CGFloat
}

extension CGFloat : _CVarArgPassedAsDouble, _CVarArgAligned {
  /// Transform `self` into a series of machine words that can be
  /// appropriately interpreted by C varargs
  @_transparent var _cVarArgEncoding: [Int] { get }
  /// Return the required alignment in bytes of
  /// the value returned by `_cVarArgEncoding`.
  @_transparent var _cVarArgAlignment: Int { get }
}

extension CGFloat : Codable {
  @_transparent init(from decoder: Decoder) throws
  @_transparent func encode(to encoder: Encoder) throws
}

extension CGFloat : Sendable {
}

@available(*, unavailable, renamed: "CGGetLastMouseDelta")
func CGGetLastMouseDelta(_ deltaX: UnsafeMutablePointer<Int32>?, _ deltaY: UnsafeMutablePointer<Int32>?)

@available(*, unavailable, renamed: "CGImage.copy(self:maskingColorComponents:)")
func CGImageCreateWithMaskingColors(_ image: CGImage?, _ components: UnsafePointer<CGFloat>) -> CGImage?

@available(*, unavailable, message: "Use addArc(center:radius:startAngle:endAngle:clockwise:transform:)")
func CGPathAddArc(_ path: CGMutablePath?, _ m: UnsafePointer<CGAffineTransform>, _ x: CGFloat, _ y: CGFloat, _ radius: CGFloat, _ startAngle: CGFloat, _ endAngle: CGFloat, _ clockwise: Bool)

@available(*, unavailable, message: "Use addArc(tangent1End:tangent2End:radius:transform:)")
func CGPathAddArcToPoint(_ path: CGMutablePath?, _ m: UnsafePointer<CGAffineTransform>, _ x1: CGFloat, _ y1: CGFloat, _ x2: CGFloat, _ y2: CGFloat, _ radius: CGFloat)

@available(*, unavailable, message: "Use addCurve(to:control1:control2:transform:)")
func CGPathAddCurveToPoint(_ path: CGMutablePath?, _ m: UnsafePointer<CGAffineTransform>, _ cp1x: CGFloat, _ cp1y: CGFloat, _ cp2x: CGFloat, _ cp2y: CGFloat, _ x: CGFloat, _ y: CGFloat)

@available(*, unavailable, message: "Use addEllipse(rect:transform:)")
func CGPathAddEllipseInRect(_ path: CGMutablePath?, _ m: UnsafePointer<CGAffineTransform>, _ rect: CGRect)

@available(*, unavailable, message: "Use addLine(to:transform:)")
func CGPathAddLineToPoint(_ path: CGMutablePath?, _ m: UnsafePointer<CGAffineTransform>, _ x: CGFloat, _ y: CGFloat)

@available(*, unavailable, message: "Use addLines(between:transform:)")
func CGPathAddLines(_ path: CGMutablePath?, _ m: UnsafePointer<CGAffineTransform>, _ points: UnsafePointer<CGPoint>, _ count: Int)

@available(*, unavailable, message: "Use addPath(_:transform:)")
func CGPathAddPath(_ path1: CGMutablePath?, _ m: UnsafePointer<CGAffineTransform>, _ path2: CGPath?)

@available(*, unavailable, message: "Use addQuadCurve(to:control:transform:)")
func CGPathAddQuadCurveToPoint(_ path: CGMutablePath?, _ m: UnsafePointer<CGAffineTransform>, _ cpx: CGFloat, _ cpy: CGFloat, _ x: CGFloat, _ y: CGFloat)

@available(*, unavailable, message: "Use addRect(_:transform:)")
func CGPathAddRect(_ path: CGMutablePath?, _ m: UnsafePointer<CGAffineTransform>, _ rect: CGRect)

@available(*, unavailable, message: "Use addRects(_:transform:)")
func CGPathAddRects(_ path: CGMutablePath?, _ m: UnsafePointer<CGAffineTransform>, _ rects: UnsafePointer<CGRect>, _ count: Int)

@available(*, unavailable, message: "Use addRelativeArc(center:radius:startAngle:delta:transform:)")
func CGPathAddRelativeArc(_ path: CGMutablePath?, _ matrix: UnsafePointer<CGAffineTransform>, _ x: CGFloat, _ y: CGFloat, _ radius: CGFloat, _ startAngle: CGFloat, _ delta: CGFloat)

@available(*, unavailable, message: "Use copy(byDashingWithPhase:lengths:transform:)")
func CGPathCreateCopyByDashingPath(_ path: CGPath?, _ transform: UnsafePointer<CGAffineTransform>, _ phase: CGFloat, _ lengths: UnsafePointer<CGFloat>, _ count: Int) -> CGPath?

@available(*, unavailable, message: "Use copy(byStroking:lineWidth:lineCap:lineJoin:miterLimit:transform:)")
func CGPathCreateCopyByStrokingPath(_ path: CGPath?, _ transform: UnsafePointer<CGAffineTransform>, _ lineWidth: CGFloat, _ lineCap: CGLineCap, _ lineJoin: CGLineJoin, _ miterLimit: CGFloat) -> CGPath?

@available(*, unavailable, message: "Use == instead")
func CGPathEqualToPath(_ path1: CGPath?, _ path2: CGPath?) -> Bool

enum CGPathFillRule : Int {
  /// Nonzero winding number fill rule.
  /// 
  /// This rule plots a ray from the interior of the region to be evaluated
  /// toward the bounds of the drawing, and sums the closed path elements
  /// that the ray crosses: +1 for counterclockwise paths, -1 for clockwise.
  /// If the sum is zero, the region is left empty; if the sum is nonzero,
  /// the region is filled.
  case winding
  /// Even-Odd fill rule.
  /// 
  /// This rule plots a ray from the interior of the region to be evaluated
  /// toward the bounds of the drawing, and sums the closed path elements
  /// that the ray crosses.
  /// If the sum is an even numner, the region is left empty; if the sum is
  /// an odd number, the region is filled.
  case evenOdd
  init?(rawValue: Int)
  typealias RawValue = Int
  var rawValue: Int { get }
}

extension CGPathFillRule : Equatable {
}

extension CGPathFillRule : Hashable {
}

extension CGPathFillRule : RawRepresentable {
}

@available(*, unavailable, message: "Use move(to:transform:)")
func CGPathMoveToPoint(_ path: CGMutablePath?, _ m: UnsafePointer<CGAffineTransform>, _ x: CGFloat, _ y: CGFloat)

@available(*, unavailable, message: "Use CGPoint.init(dictionaryRepresentation:)")
func CGPointMakeWithDictionaryRepresentation(_ dict: CFDictionary?, _ point: UnsafeMutablePointer<CGPoint>) -> Bool

@available(*, unavailable, message: "Use divided(atDistance:from:)")
func CGRectDivide(_ rect: CGRect, _ slice: UnsafeMutablePointer<CGRect>, _ remainder: UnsafeMutablePointer<CGRect>, _ amount: CGFloat, _ edge: CGRectEdge)

@available(*, unavailable, message: "Use CGRect.init(dictionaryRepresentation:)")
func CGRectMakeWithDictionaryRepresentation(_ dict: CFDictionary?, _ rect: UnsafeMutablePointer<CGRect>) -> Bool

@available(*, unavailable, message: "Use CGSize.init(dictionaryRepresentation:)")
func CGSizeMakeWithDictionaryRepresentation(_ dict: CFDictionary?, _ size: UnsafeMutablePointer<CGSize>) -> Bool

protocol _CGColorInitTrampoline {
  init?(colorSpace space: CGColorSpace, components: UnsafePointer<CGFloat>)
}

extension _CGColorInitTrampoline {
  init(_colorLiteralRed red: Float, green: Float, blue: Float, alpha: Float)
}

@_transparent func acos(_ x: CGFloat) -> CGFloat

@_transparent func acosh(_ x: CGFloat) -> CGFloat

@_transparent func asin(_ x: CGFloat) -> CGFloat

@_transparent func asinh(_ x: CGFloat) -> CGFloat

@_transparent func atan(_ x: CGFloat) -> CGFloat

@_transparent func atan2(_ lhs: CGFloat, _ rhs: CGFloat) -> CGFloat

@_transparent func atanh(_ x: CGFloat) -> CGFloat

@_transparent func cbrt(_ x: CGFloat) -> CGFloat

@_transparent func copysign(_ lhs: CGFloat, _ rhs: CGFloat) -> CGFloat

@_transparent func cos(_ x: CGFloat) -> CGFloat

@_transparent func cosh(_ x: CGFloat) -> CGFloat

@_transparent func erf(_ x: CGFloat) -> CGFloat

@_transparent func erfc(_ x: CGFloat) -> CGFloat

@_transparent func exp(_ x: CGFloat) -> CGFloat

@_transparent func exp2(_ x: CGFloat) -> CGFloat

@_transparent func expm1(_ x: CGFloat) -> CGFloat

@_transparent func fdim(_ lhs: CGFloat, _ rhs: CGFloat) -> CGFloat

@_transparent func fmax(_ lhs: CGFloat, _ rhs: CGFloat) -> CGFloat

@_transparent func fmin(_ lhs: CGFloat, _ rhs: CGFloat) -> CGFloat

@available(*, unavailable, message: "use the floatingPointClass property.")
@_transparent func fpclassify(_ x: CGFloat) -> Int

@_transparent func hypot(_ lhs: CGFloat, _ rhs: CGFloat) -> CGFloat

@available(swift, deprecated: 4.2, message: "use the exponent property.")
@_transparent func ilogb(_ x: CGFloat) -> Int

@available(*, unavailable, message: "use the isFinite property.")
func isfinite(_ value: CGFloat) -> Bool

@available(*, unavailable, message: "use the isInfinite property.")
func isinf(_ value: CGFloat) -> Bool

@available(*, unavailable, message: "use the isNaN property.")
func isnan(_ value: CGFloat) -> Bool

@available(*, unavailable, message: "use the isNormal property.")
func isnormal(_ value: CGFloat) -> Bool

@_transparent func j0(_ x: CGFloat) -> CGFloat

@_transparent func j1(_ x: CGFloat) -> CGFloat

@_transparent func jn(_ n: Int, _ x: CGFloat) -> CGFloat

@available(*, unavailable, message: "Use CGColor.black")
var kCGColorBlack: CFString { get }

@available(*, unavailable, message: "Use CGColor.clear")
var kCGColorClear: CFString { get }

@available(*, unavailable, message: "Use CGColor.white")
var kCGColorWhite: CFString { get }

@available(swift, deprecated: 4.2, renamed: "scalbn")
@_transparent func ldexp(_ x: CGFloat, _ n: Int) -> CGFloat

@_transparent func lgamma(_ x: CGFloat) -> (CGFloat, Int)

@_transparent func log(_ x: CGFloat) -> CGFloat

@_transparent func log10(_ x: CGFloat) -> CGFloat

@_transparent func log1p(_ x: CGFloat) -> CGFloat

@_transparent func log2(_ x: CGFloat) -> CGFloat

@_transparent func logb(_ x: CGFloat) -> CGFloat

@available(swift, deprecated: 4.2, message: "use CGFloat(nan: CGFloat.RawSignificand) instead.")
@_transparent func nan(_ tag: String) -> CGFloat

@_transparent func nearbyint(_ x: CGFloat) -> CGFloat

@_transparent func nextafter(_ lhs: CGFloat, _ rhs: CGFloat) -> CGFloat

@_transparent func pow(_ lhs: CGFloat, _ rhs: CGFloat) -> CGFloat

@_transparent func remquo(_ x: CGFloat, _ y: CGFloat) -> (CGFloat, Int)

@_transparent func rint(_ x: CGFloat) -> CGFloat

@available(*, unavailable, message: "use the sign property.")
func signbit(_ value: CGFloat) -> Int

@_transparent func sin(_ x: CGFloat) -> CGFloat

@_transparent func sinh(_ x: CGFloat) -> CGFloat

@_transparent func tan(_ x: CGFloat) -> CGFloat

@_transparent func tanh(_ x: CGFloat) -> CGFloat

@_transparent func tgamma(_ x: CGFloat) -> CGFloat

@_transparent func y0(_ x: CGFloat) -> CGFloat

@_transparent func y1(_ x: CGFloat) -> CGFloat

@_transparent func yn(_ n: Int, _ x: CGFloat) -> CGFloat

extension UInt8 {
  @_transparent init(_ value: CGFloat)
}

extension Int8 {
  @_transparent init(_ value: CGFloat)
}

extension UInt16 {
  @_transparent init(_ value: CGFloat)
}

extension Int16 {
  @_transparent init(_ value: CGFloat)
}

extension UInt32 {
  @_transparent init(_ value: CGFloat)
}

extension Int32 {
  @_transparent init(_ value: CGFloat)
}

extension UInt64 {
  @_transparent init(_ value: CGFloat)
}

extension Int64 {
  @_transparent init(_ value: CGFloat)
}

extension UInt {
  @_transparent init(_ value: CGFloat)
}

extension Int {
  @_transparent init(_ value: CGFloat)
}

extension Double {
  @_transparent init(_ value: CGFloat)
}

extension Float {
  @_transparent init(_ value: CGFloat)
}

extension CGAffineTransform : Equatable {
  static func == (lhs: CGAffineTransform, rhs: CGAffineTransform) -> Bool
}

extension CGColor {
  @available(macOS 10.3, iOS 2.0, *)
  var components: [CGFloat]? { get }
}

extension CGColor : _CGColorInitTrampoline, _ExpressibleByColorLiteral {
}

extension CGColorSpace {
  var colorTable: [UInt8]? { get }
}

extension CGContext {
  func setLineDash(phase: CGFloat, lengths: [CGFloat])
  func move(to point: CGPoint)
  func addLine(to point: CGPoint)
  func addCurve(to end: CGPoint, control1: CGPoint, control2: CGPoint)
  func addQuadCurve(to end: CGPoint, control: CGPoint)
  func addRects(_ rects: [CGRect])
  func addLines(between points: [CGPoint])
  func addArc(center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool)
  func addArc(tangent1End: CGPoint, tangent2End: CGPoint, radius: CGFloat)
  /// Fills the current path using the specified rule (winding by default).
  ///
  /// Any open subpath is implicitly closed.
  func fillPath(using rule: CGPathFillRule = .winding)
  /// Intersects the current path with the current clipping region and uses the
  /// result as the new clipping region for subsequent drawing.
  ///
  /// Uses the specified fill rule (winding by default) to determine which
  /// areas to treat as the interior of the clipping region. When evaluating
  /// the path, any open subpath is implicitly closed.
  func clip(using rule: CGPathFillRule = .winding)
  func fill(_ rects: [CGRect])
  func strokeLineSegments(between points: [CGPoint])
  func clip(to rects: [CGRect])
  func draw(_ image: CGImage, in rect: CGRect, byTiling: Bool = false)
  var textPosition: CGPoint
  func showGlyphs(_ glyphs: [CGGlyph], at positions: [CGPoint])
}

extension CGPoint {
  static var zero: CGPoint { get }
  @_transparent init(x: Int, y: Int)
  @_transparent init(x: Double, y: Double)
  init?(dictionaryRepresentation dict: CFDictionary)
}

extension CGPoint : CustomReflectable {
  var customMirror: Mirror { get }
}

extension CGPoint : _CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "CGPoint.customPlaygroundQuickLook will be removed in a future Swift version")
  var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension CGPoint : CustomDebugStringConvertible {
  var debugDescription: String { get }
}

extension CGPoint : Equatable {
  @_transparent static func == (lhs: CGPoint, rhs: CGPoint) -> Bool
}

extension CGPoint : Codable {
  init(from decoder: Decoder) throws
  func encode(to encoder: Encoder) throws
}

extension CGSize {
  static var zero: CGSize { get }
  @_transparent init(width: Int, height: Int)
  @_transparent init(width: Double, height: Double)
  init?(dictionaryRepresentation dict: CFDictionary)
}

extension CGSize : CustomReflectable {
  var customMirror: Mirror { get }
}

extension CGSize : _CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "CGSize.customPlaygroundQuickLook will be removed in a future Swift version")
  var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension CGSize : CustomDebugStringConvertible {
  var debugDescription: String { get }
}

extension CGSize : Equatable {
  @_transparent static func == (lhs: CGSize, rhs: CGSize) -> Bool
}

extension CGSize : Codable {
  init(from decoder: Decoder) throws
  func encode(to encoder: Encoder) throws
}

extension CGVector {
  static var zero: CGVector { get }
  @_transparent init(dx: Int, dy: Int)
  @_transparent init(dx: Double, dy: Double)
}

extension CGVector : Equatable {
  @_transparent static func == (lhs: CGVector, rhs: CGVector) -> Bool
}

extension CGVector : CustomDebugStringConvertible {
  var debugDescription: String { get }
}

extension CGVector : Codable {
  init(from decoder: Decoder) throws
  func encode(to encoder: Encoder) throws
}

extension CGRect {
  static var zero: CGRect { get }
  @_transparent init(x: CGFloat, y: CGFloat, width: CGFloat, height: CGFloat)
  @_transparent init(x: Double, y: Double, width: Double, height: Double)
  @_transparent init(x: Int, y: Int, width: Int, height: Int)
  init?(dictionaryRepresentation dict: CFDictionary)
  @_transparent func divided(atDistance: CGFloat, from fromEdge: CGRectEdge) -> (slice: CGRect, remainder: CGRect)
  @available(*, unavailable, renamed: "minX")
  var x: CGFloat { get }
  @available(*, unavailable, renamed: "minY")
  var y: CGFloat { get }
}

extension CGRect : CustomReflectable {
  var customMirror: Mirror { get }
}

extension CGRect : _CustomPlaygroundQuickLookable {
  @available(*, deprecated, message: "CGRect.customPlaygroundQuickLook will be removed in a future Swift version")
  var customPlaygroundQuickLook: PlaygroundQuickLook { get }
}

extension CGRect : CustomDebugStringConvertible {
  var debugDescription: String { get }
}

extension CGRect : Equatable {
  @_transparent static func == (lhs: CGRect, rhs: CGRect) -> Bool
}

extension CGRect : Codable {
  init(from decoder: Decoder) throws
  func encode(to encoder: Encoder) throws
}

extension CGAffineTransform {
  static var identity: CGAffineTransform { get }
}

extension CGAffineTransform : Codable {
  init(from decoder: Decoder) throws
  func encode(to encoder: Encoder) throws
}

extension CGImage {
  func copy(maskingColorComponents components: [CGFloat]) -> CGImage?
}

extension CGContext {
  func draw(_ layer: CGLayer, in rect: CGRect)
  func draw(_ layer: CGLayer, at point: CGPoint)
}

extension CGPath {
  func copy(dashingWithPhase phase: CGFloat, lengths: [CGFloat], transform: CGAffineTransform = .identity) -> CGPath
  func copy(strokingWithWidth lineWidth: CGFloat, lineCap: CGLineCap, lineJoin: CGLineJoin, miterLimit: CGFloat, transform: CGAffineTransform = .identity) -> CGPath
  func contains(_ point: CGPoint, using rule: CGPathFillRule = .winding, transform: CGAffineTransform = .identity) -> Bool
}

extension CGMutablePath {
  func addRoundedRect(in rect: CGRect, cornerWidth: CGFloat, cornerHeight: CGFloat, transform: CGAffineTransform = .identity)
  func move(to point: CGPoint, transform: CGAffineTransform = .identity)
  func addLine(to point: CGPoint, transform: CGAffineTransform = .identity)
  func addQuadCurve(to end: CGPoint, control: CGPoint, transform: CGAffineTransform = .identity)
  func addCurve(to end: CGPoint, control1: CGPoint, control2: CGPoint, transform: CGAffineTransform = .identity)
  func addRect(_ rect: CGRect, transform: CGAffineTransform = .identity)
  func addRects(_ rects: [CGRect], transform: CGAffineTransform = .identity)
  func addLines(between points: [CGPoint], transform: CGAffineTransform = .identity)
  func addEllipse(in rect: CGRect, transform: CGAffineTransform = .identity)
  func addRelativeArc(center: CGPoint, radius: CGFloat, startAngle: CGFloat, delta: CGFloat, transform: CGAffineTransform = .identity)
  func addArc(center: CGPoint, radius: CGFloat, startAngle: CGFloat, endAngle: CGFloat, clockwise: Bool, transform: CGAffineTransform = .identity)
  func addArc(tangent1End: CGPoint, tangent2End: CGPoint, radius: CGFloat, transform: CGAffineTransform = .identity)
  func addPath(_ path: CGPath, transform: CGAffineTransform = .identity)
}

@available(*, unavailable, renamed: "CGFloat.leastNormalMagnitude")
let CGFLOAT_MIN: CGFloat { get }

@available(*, unavailable, renamed: "CGFloat.greatestFiniteMagnitude")
let CGFLOAT_MAX: CGFloat { get }

@available(*, unavailable, message: "Use CGColor.white")
let kCGColorWhite: CFString { get }

@available(*, unavailable, message: "Use CGColor.black")
let kCGColorBlack: CFString { get }

@available(*, unavailable, message: "Use CGColor.clear")
let kCGColorClear: CFString { get }

